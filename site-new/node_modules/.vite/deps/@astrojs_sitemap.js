import {
  ZodError,
  mod
} from "./chunk-ROWVQBKT.js";
import {
  require_url
} from "./chunk-X3EW236P.js";
import {
  require_fs,
  require_path
} from "./chunk-5NDHJRA6.js";
import {
  __commonJS,
  __toESM
} from "./chunk-OZI5HTJH.js";

// browser-external:stream
var require_stream = __commonJS({
  "browser-external:stream"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "stream" has been externalized for browser compatibility. Cannot access "stream.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/sitemap/dist/lib/errors.js
var require_errors = __commonJS({
  "node_modules/sitemap/dist/lib/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EmptySitemap = exports.EmptyStream = exports.InvalidVideoPriceCurrency = exports.InvalidVideoResolution = exports.InvalidVideoPriceType = exports.InvalidVideoRestrictionRelationship = exports.InvalidVideoRestriction = exports.InvalidVideoFamilyFriendly = exports.InvalidVideoCategory = exports.InvalidVideoTagCount = exports.InvalidVideoViewCount = exports.InvalidVideoTitle = exports.XMLLintUnavailable = exports.InvalidNewsAccessValue = exports.InvalidNewsFormat = exports.InvalidAttr = exports.InvalidAttrValue = exports.InvalidVideoRating = exports.InvalidVideoDescription = exports.InvalidVideoDuration = exports.InvalidVideoFormat = exports.UndefinedTargetFolder = exports.PriorityInvalidError = exports.ChangeFreqInvalidError = exports.NoConfigError = exports.NoURLError = void 0;
    var NoURLError = class extends Error {
      constructor(message) {
        super(message || "URL is required");
        this.name = "NoURLError";
        Error.captureStackTrace(this, NoURLError);
      }
    };
    exports.NoURLError = NoURLError;
    var NoConfigError = class extends Error {
      constructor(message) {
        super(message || "SitemapItem requires a configuration");
        this.name = "NoConfigError";
        Error.captureStackTrace(this, NoConfigError);
      }
    };
    exports.NoConfigError = NoConfigError;
    var ChangeFreqInvalidError = class extends Error {
      constructor(url, changefreq) {
        super(`${url}: changefreq "${changefreq}" is invalid`);
        this.name = "ChangeFreqInvalidError";
        Error.captureStackTrace(this, ChangeFreqInvalidError);
      }
    };
    exports.ChangeFreqInvalidError = ChangeFreqInvalidError;
    var PriorityInvalidError = class extends Error {
      constructor(url, priority) {
        super(`${url}: priority "${priority}" must be a number between 0 and 1 inclusive`);
        this.name = "PriorityInvalidError";
        Error.captureStackTrace(this, PriorityInvalidError);
      }
    };
    exports.PriorityInvalidError = PriorityInvalidError;
    var UndefinedTargetFolder = class extends Error {
      constructor(message) {
        super(message || "Target folder must exist");
        this.name = "UndefinedTargetFolder";
        Error.captureStackTrace(this, UndefinedTargetFolder);
      }
    };
    exports.UndefinedTargetFolder = UndefinedTargetFolder;
    var InvalidVideoFormat = class extends Error {
      constructor(url) {
        super(`${url} video must include thumbnail_loc, title and description fields for videos`);
        this.name = "InvalidVideoFormat";
        Error.captureStackTrace(this, InvalidVideoFormat);
      }
    };
    exports.InvalidVideoFormat = InvalidVideoFormat;
    var InvalidVideoDuration = class extends Error {
      constructor(url, duration) {
        super(`${url} duration "${duration}" must be an integer of seconds between 0 and 28800`);
        this.name = "InvalidVideoDuration";
        Error.captureStackTrace(this, InvalidVideoDuration);
      }
    };
    exports.InvalidVideoDuration = InvalidVideoDuration;
    var InvalidVideoDescription = class extends Error {
      constructor(url, length) {
        const message = `${url}: video description is too long ${length} vs limit of 2048 characters.`;
        super(message);
        this.name = "InvalidVideoDescription";
        Error.captureStackTrace(this, InvalidVideoDescription);
      }
    };
    exports.InvalidVideoDescription = InvalidVideoDescription;
    var InvalidVideoRating = class extends Error {
      constructor(url, title, rating) {
        super(`${url}: video "${title}" rating "${rating}" must be between 0 and 5 inclusive`);
        this.name = "InvalidVideoRating";
        Error.captureStackTrace(this, InvalidVideoRating);
      }
    };
    exports.InvalidVideoRating = InvalidVideoRating;
    var InvalidAttrValue = class extends Error {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      constructor(key, val, validator) {
        super('"' + val + '" tested against: ' + validator + ' is not a valid value for attr: "' + key + '"');
        this.name = "InvalidAttrValue";
        Error.captureStackTrace(this, InvalidAttrValue);
      }
    };
    exports.InvalidAttrValue = InvalidAttrValue;
    var InvalidAttr = class extends Error {
      constructor(key) {
        super('"' + key + '" is malformed');
        this.name = "InvalidAttr";
        Error.captureStackTrace(this, InvalidAttr);
      }
    };
    exports.InvalidAttr = InvalidAttr;
    var InvalidNewsFormat = class extends Error {
      constructor(url) {
        super(`${url} News must include publication, publication name, publication language, title, and publication_date for news`);
        this.name = "InvalidNewsFormat";
        Error.captureStackTrace(this, InvalidNewsFormat);
      }
    };
    exports.InvalidNewsFormat = InvalidNewsFormat;
    var InvalidNewsAccessValue = class extends Error {
      constructor(url, access) {
        super(`${url} News access "${access}" must be either Registration, Subscription or not be present`);
        this.name = "InvalidNewsAccessValue";
        Error.captureStackTrace(this, InvalidNewsAccessValue);
      }
    };
    exports.InvalidNewsAccessValue = InvalidNewsAccessValue;
    var XMLLintUnavailable = class extends Error {
      constructor(message) {
        super(message || "xmlLint is not installed. XMLLint is required to validate");
        this.name = "XMLLintUnavailable";
        Error.captureStackTrace(this, XMLLintUnavailable);
      }
    };
    exports.XMLLintUnavailable = XMLLintUnavailable;
    var InvalidVideoTitle = class extends Error {
      constructor(url, length) {
        super(`${url}: video title is too long ${length} vs 100 character limit`);
        this.name = "InvalidVideoTitle";
        Error.captureStackTrace(this, InvalidVideoTitle);
      }
    };
    exports.InvalidVideoTitle = InvalidVideoTitle;
    var InvalidVideoViewCount = class extends Error {
      constructor(url, count) {
        super(`${url}: video view count must be positive, view count was ${count}`);
        this.name = "InvalidVideoViewCount";
        Error.captureStackTrace(this, InvalidVideoViewCount);
      }
    };
    exports.InvalidVideoViewCount = InvalidVideoViewCount;
    var InvalidVideoTagCount = class extends Error {
      constructor(url, count) {
        super(`${url}: video can have no more than 32 tags, this has ${count}`);
        this.name = "InvalidVideoTagCount";
        Error.captureStackTrace(this, InvalidVideoTagCount);
      }
    };
    exports.InvalidVideoTagCount = InvalidVideoTagCount;
    var InvalidVideoCategory = class extends Error {
      constructor(url, count) {
        super(`${url}: video category can only be 256 characters but was passed ${count}`);
        this.name = "InvalidVideoCategory";
        Error.captureStackTrace(this, InvalidVideoCategory);
      }
    };
    exports.InvalidVideoCategory = InvalidVideoCategory;
    var InvalidVideoFamilyFriendly = class extends Error {
      constructor(url, fam) {
        super(`${url}: video family friendly must be yes or no, was passed "${fam}"`);
        this.name = "InvalidVideoFamilyFriendly";
        Error.captureStackTrace(this, InvalidVideoFamilyFriendly);
      }
    };
    exports.InvalidVideoFamilyFriendly = InvalidVideoFamilyFriendly;
    var InvalidVideoRestriction = class extends Error {
      constructor(url, code) {
        super(`${url}: video restriction must be one or more two letter country codes. Was passed "${code}"`);
        this.name = "InvalidVideoRestriction";
        Error.captureStackTrace(this, InvalidVideoRestriction);
      }
    };
    exports.InvalidVideoRestriction = InvalidVideoRestriction;
    var InvalidVideoRestrictionRelationship = class extends Error {
      constructor(url, val) {
        super(`${url}: video restriction relationship must be either allow or deny. Was passed "${val}"`);
        this.name = "InvalidVideoRestrictionRelationship";
        Error.captureStackTrace(this, InvalidVideoRestrictionRelationship);
      }
    };
    exports.InvalidVideoRestrictionRelationship = InvalidVideoRestrictionRelationship;
    var InvalidVideoPriceType = class extends Error {
      constructor(url, priceType, price) {
        super(priceType === void 0 && price === "" ? `${url}: video priceType is required when price is not provided` : `${url}: video price type "${priceType}" is not "rent" or "purchase"`);
        this.name = "InvalidVideoPriceType";
        Error.captureStackTrace(this, InvalidVideoPriceType);
      }
    };
    exports.InvalidVideoPriceType = InvalidVideoPriceType;
    var InvalidVideoResolution = class extends Error {
      constructor(url, resolution) {
        super(`${url}: video price resolution "${resolution}" is not hd or sd`);
        this.name = "InvalidVideoResolution";
        Error.captureStackTrace(this, InvalidVideoResolution);
      }
    };
    exports.InvalidVideoResolution = InvalidVideoResolution;
    var InvalidVideoPriceCurrency = class extends Error {
      constructor(url, currency) {
        super(`${url}: video price currency "${currency}" must be a three capital letter abbrieviation for the country currency`);
        this.name = "InvalidVideoPriceCurrency";
        Error.captureStackTrace(this, InvalidVideoPriceCurrency);
      }
    };
    exports.InvalidVideoPriceCurrency = InvalidVideoPriceCurrency;
    var EmptyStream = class extends Error {
      constructor() {
        super("You have ended the stream before anything was written. streamToPromise MUST be called before ending the stream.");
        this.name = "EmptyStream";
        Error.captureStackTrace(this, EmptyStream);
      }
    };
    exports.EmptyStream = EmptyStream;
    var EmptySitemap = class extends Error {
      constructor() {
        super("You ended the stream without writing anything.");
        this.name = "EmptySitemap";
        Error.captureStackTrace(this, EmptyStream);
      }
    };
    exports.EmptySitemap = EmptySitemap;
  }
});

// node_modules/sitemap/dist/lib/types.js
var require_types = __commonJS({
  "node_modules/sitemap/dist/lib/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndexTagNames = exports.TagNames = exports.ErrorLevel = exports.isAllowDeny = exports.EnumAllowDeny = exports.isValidYesNo = exports.EnumYesNo = exports.isValidChangeFreq = exports.CHANGEFREQ = exports.isResolution = exports.isPriceType = exports.validators = exports.EnumChangefreq = void 0;
    var EnumChangefreq;
    (function(EnumChangefreq2) {
      EnumChangefreq2["DAILY"] = "daily";
      EnumChangefreq2["MONTHLY"] = "monthly";
      EnumChangefreq2["ALWAYS"] = "always";
      EnumChangefreq2["HOURLY"] = "hourly";
      EnumChangefreq2["WEEKLY"] = "weekly";
      EnumChangefreq2["YEARLY"] = "yearly";
      EnumChangefreq2["NEVER"] = "never";
    })(EnumChangefreq = exports.EnumChangefreq || (exports.EnumChangefreq = {}));
    var allowDeny = /^(?:allow|deny)$/;
    exports.validators = {
      "price:currency": /^[A-Z]{3}$/,
      "price:type": /^(?:rent|purchase|RENT|PURCHASE)$/,
      "price:resolution": /^(?:HD|hd|sd|SD)$/,
      "platform:relationship": allowDeny,
      "restriction:relationship": allowDeny,
      restriction: /^([A-Z]{2}( +[A-Z]{2})*)?$/,
      platform: /^((web|mobile|tv)( (web|mobile|tv))*)?$/,
      language: /^zh-cn|zh-tw|([a-z]{2,3})$/,
      genres: /^(PressRelease|Satire|Blog|OpEd|Opinion|UserGenerated)(, *(PressRelease|Satire|Blog|OpEd|Opinion|UserGenerated))*$/,
      stock_tickers: /^(\w+:\w+(, *\w+:\w+){0,4})?$/
    };
    function isPriceType(pt) {
      return exports.validators["price:type"].test(pt);
    }
    exports.isPriceType = isPriceType;
    function isResolution(res) {
      return exports.validators["price:resolution"].test(res);
    }
    exports.isResolution = isResolution;
    exports.CHANGEFREQ = Object.values(EnumChangefreq);
    function isValidChangeFreq(freq) {
      return exports.CHANGEFREQ.includes(freq);
    }
    exports.isValidChangeFreq = isValidChangeFreq;
    var EnumYesNo;
    (function(EnumYesNo2) {
      EnumYesNo2["YES"] = "YES";
      EnumYesNo2["NO"] = "NO";
      EnumYesNo2["Yes"] = "Yes";
      EnumYesNo2["No"] = "No";
      EnumYesNo2["yes"] = "yes";
      EnumYesNo2["no"] = "no";
    })(EnumYesNo = exports.EnumYesNo || (exports.EnumYesNo = {}));
    function isValidYesNo(yn) {
      return /^YES|NO|[Yy]es|[Nn]o$/.test(yn);
    }
    exports.isValidYesNo = isValidYesNo;
    var EnumAllowDeny;
    (function(EnumAllowDeny2) {
      EnumAllowDeny2["ALLOW"] = "allow";
      EnumAllowDeny2["DENY"] = "deny";
    })(EnumAllowDeny = exports.EnumAllowDeny || (exports.EnumAllowDeny = {}));
    function isAllowDeny(ad) {
      return allowDeny.test(ad);
    }
    exports.isAllowDeny = isAllowDeny;
    var ErrorLevel;
    (function(ErrorLevel2) {
      ErrorLevel2["SILENT"] = "silent";
      ErrorLevel2["WARN"] = "warn";
      ErrorLevel2["THROW"] = "throw";
    })(ErrorLevel = exports.ErrorLevel || (exports.ErrorLevel = {}));
    var TagNames;
    (function(TagNames2) {
      TagNames2["url"] = "url";
      TagNames2["loc"] = "loc";
      TagNames2["urlset"] = "urlset";
      TagNames2["lastmod"] = "lastmod";
      TagNames2["changefreq"] = "changefreq";
      TagNames2["priority"] = "priority";
      TagNames2["video:thumbnail_loc"] = "video:thumbnail_loc";
      TagNames2["video:video"] = "video:video";
      TagNames2["video:title"] = "video:title";
      TagNames2["video:description"] = "video:description";
      TagNames2["video:tag"] = "video:tag";
      TagNames2["video:duration"] = "video:duration";
      TagNames2["video:player_loc"] = "video:player_loc";
      TagNames2["video:content_loc"] = "video:content_loc";
      TagNames2["image:image"] = "image:image";
      TagNames2["image:loc"] = "image:loc";
      TagNames2["image:geo_location"] = "image:geo_location";
      TagNames2["image:license"] = "image:license";
      TagNames2["image:title"] = "image:title";
      TagNames2["image:caption"] = "image:caption";
      TagNames2["video:requires_subscription"] = "video:requires_subscription";
      TagNames2["video:publication_date"] = "video:publication_date";
      TagNames2["video:id"] = "video:id";
      TagNames2["video:restriction"] = "video:restriction";
      TagNames2["video:family_friendly"] = "video:family_friendly";
      TagNames2["video:view_count"] = "video:view_count";
      TagNames2["video:uploader"] = "video:uploader";
      TagNames2["video:expiration_date"] = "video:expiration_date";
      TagNames2["video:platform"] = "video:platform";
      TagNames2["video:price"] = "video:price";
      TagNames2["video:rating"] = "video:rating";
      TagNames2["video:category"] = "video:category";
      TagNames2["video:live"] = "video:live";
      TagNames2["video:gallery_loc"] = "video:gallery_loc";
      TagNames2["news:news"] = "news:news";
      TagNames2["news:publication"] = "news:publication";
      TagNames2["news:name"] = "news:name";
      TagNames2["news:access"] = "news:access";
      TagNames2["news:genres"] = "news:genres";
      TagNames2["news:publication_date"] = "news:publication_date";
      TagNames2["news:title"] = "news:title";
      TagNames2["news:keywords"] = "news:keywords";
      TagNames2["news:stock_tickers"] = "news:stock_tickers";
      TagNames2["news:language"] = "news:language";
      TagNames2["mobile:mobile"] = "mobile:mobile";
      TagNames2["xhtml:link"] = "xhtml:link";
      TagNames2["expires"] = "expires";
    })(TagNames = exports.TagNames || (exports.TagNames = {}));
    var IndexTagNames;
    (function(IndexTagNames2) {
      IndexTagNames2["sitemap"] = "sitemap";
      IndexTagNames2["sitemapindex"] = "sitemapindex";
      IndexTagNames2["loc"] = "loc";
      IndexTagNames2["lastmod"] = "lastmod";
    })(IndexTagNames = exports.IndexTagNames || (exports.IndexTagNames = {}));
  }
});

// node_modules/sitemap/dist/lib/sitemap-xml.js
var require_sitemap_xml = __commonJS({
  "node_modules/sitemap/dist/lib/sitemap-xml.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.element = exports.ctag = exports.otag = exports.text = void 0;
    var invalidXMLUnicodeRegex = (
      // eslint-disable-next-line no-control-regex
      /[\u0000-\u0008\u000B\u000C\u000E-\u001F\u007F-\u0084\u0086-\u009F\uD800-\uDFFF\uFDD0-\uFDDF\u{1FFFE}-\u{1FFFF}\u{2FFFE}-\u{2FFFF}\u{3FFFE}-\u{3FFFF}\u{4FFFE}-\u{4FFFF}\u{5FFFE}-\u{5FFFF}\u{6FFFE}-\u{6FFFF}\u{7FFFE}-\u{7FFFF}\u{8FFFE}-\u{8FFFF}\u{9FFFE}-\u{9FFFF}\u{AFFFE}-\u{AFFFF}\u{BFFFE}-\u{BFFFF}\u{CFFFE}-\u{CFFFF}\u{DFFFE}-\u{DFFFF}\u{EFFFE}-\u{EFFFF}\u{FFFFE}-\u{FFFFF}\u{10FFFE}-\u{10FFFF}]/gu
    );
    var amp = /&/g;
    var lt = /</g;
    var apos = /'/g;
    var quot = /"/g;
    function text(txt) {
      return txt.replace(amp, "&amp;").replace(lt, "&lt;").replace(invalidXMLUnicodeRegex, "");
    }
    exports.text = text;
    function otag(nodeName, attrs, selfClose = false) {
      let attrstr = "";
      for (const k in attrs) {
        const val = attrs[k].replace(amp, "&amp;").replace(lt, "&lt;").replace(apos, "&apos;").replace(quot, "&quot;").replace(invalidXMLUnicodeRegex, "");
        attrstr += ` ${k}="${val}"`;
      }
      return `<${nodeName}${attrstr}${selfClose ? "/" : ""}>`;
    }
    exports.otag = otag;
    function ctag(nodeName) {
      return `</${nodeName}>`;
    }
    exports.ctag = ctag;
    function element(nodeName, attrs, innerText) {
      if (typeof attrs === "string") {
        return otag(nodeName) + text(attrs) + ctag(nodeName);
      } else if (innerText) {
        return otag(nodeName, attrs) + text(innerText) + ctag(nodeName);
      } else {
        return otag(nodeName, attrs, true);
      }
    }
    exports.element = element;
  }
});

// node_modules/sitemap/dist/lib/sitemap-item-stream.js
var require_sitemap_item_stream = __commonJS({
  "node_modules/sitemap/dist/lib/sitemap-item-stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SitemapItemStream = void 0;
    var stream_1 = require_stream();
    var errors_1 = require_errors();
    var types_1 = require_types();
    var sitemap_xml_1 = require_sitemap_xml();
    function attrBuilder(conf, keys) {
      if (typeof keys === "string") {
        keys = [keys];
      }
      const iv = {};
      return keys.reduce((attrs, key) => {
        if (conf[key] !== void 0) {
          const keyAr = key.split(":");
          if (keyAr.length !== 2) {
            throw new errors_1.InvalidAttr(key);
          }
          attrs[keyAr[1]] = conf[key];
        }
        return attrs;
      }, iv);
    }
    var SitemapItemStream = class extends stream_1.Transform {
      constructor(opts = { level: types_1.ErrorLevel.WARN }) {
        opts.objectMode = true;
        super(opts);
        this.level = opts.level || types_1.ErrorLevel.WARN;
      }
      _transform(item, encoding, callback) {
        this.push((0, sitemap_xml_1.otag)(types_1.TagNames.url));
        this.push((0, sitemap_xml_1.element)(types_1.TagNames.loc, item.url));
        if (item.lastmod) {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames.lastmod, item.lastmod));
        }
        if (item.changefreq) {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames.changefreq, item.changefreq));
        }
        if (item.priority !== void 0 && item.priority !== null) {
          if (item.fullPrecisionPriority) {
            this.push((0, sitemap_xml_1.element)(types_1.TagNames.priority, item.priority.toString()));
          } else {
            this.push((0, sitemap_xml_1.element)(types_1.TagNames.priority, item.priority.toFixed(1)));
          }
        }
        item.video.forEach((video) => {
          this.push((0, sitemap_xml_1.otag)(types_1.TagNames["video:video"]));
          this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:thumbnail_loc"], video.thumbnail_loc));
          this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:title"], video.title));
          this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:description"], video.description));
          if (video.content_loc) {
            this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:content_loc"], video.content_loc));
          }
          if (video.player_loc) {
            this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:player_loc"], attrBuilder(video, [
              "player_loc:autoplay",
              "player_loc:allow_embed"
            ]), video.player_loc));
          }
          if (video.duration) {
            this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:duration"], video.duration.toString()));
          }
          if (video.expiration_date) {
            this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:expiration_date"], video.expiration_date));
          }
          if (video.rating !== void 0) {
            this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:rating"], video.rating.toString()));
          }
          if (video.view_count !== void 0) {
            this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:view_count"], video.view_count.toString()));
          }
          if (video.publication_date) {
            this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:publication_date"], video.publication_date));
          }
          for (const tag of video.tag) {
            this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:tag"], tag));
          }
          if (video.category) {
            this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:category"], video.category));
          }
          if (video.family_friendly) {
            this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:family_friendly"], video.family_friendly));
          }
          if (video.restriction) {
            this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:restriction"], attrBuilder(video, "restriction:relationship"), video.restriction));
          }
          if (video.gallery_loc) {
            this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:gallery_loc"], { title: video["gallery_loc:title"] }, video.gallery_loc));
          }
          if (video.price) {
            this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:price"], attrBuilder(video, [
              "price:resolution",
              "price:currency",
              "price:type"
            ]), video.price));
          }
          if (video.requires_subscription) {
            this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:requires_subscription"], video.requires_subscription));
          }
          if (video.uploader) {
            this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:uploader"], attrBuilder(video, "uploader:info"), video.uploader));
          }
          if (video.platform) {
            this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:platform"], attrBuilder(video, "platform:relationship"), video.platform));
          }
          if (video.live) {
            this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:live"], video.live));
          }
          if (video.id) {
            this.push((0, sitemap_xml_1.element)(types_1.TagNames["video:id"], { type: "url" }, video.id));
          }
          this.push((0, sitemap_xml_1.ctag)(types_1.TagNames["video:video"]));
        });
        item.links.forEach((link) => {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames["xhtml:link"], {
            rel: "alternate",
            hreflang: link.lang || link.hreflang,
            href: link.url
          }));
        });
        if (item.expires) {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames.expires, new Date(item.expires).toISOString()));
        }
        if (item.androidLink) {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames["xhtml:link"], {
            rel: "alternate",
            href: item.androidLink
          }));
        }
        if (item.ampLink) {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames["xhtml:link"], {
            rel: "amphtml",
            href: item.ampLink
          }));
        }
        if (item.news) {
          this.push((0, sitemap_xml_1.otag)(types_1.TagNames["news:news"]));
          this.push((0, sitemap_xml_1.otag)(types_1.TagNames["news:publication"]));
          this.push((0, sitemap_xml_1.element)(types_1.TagNames["news:name"], item.news.publication.name));
          this.push((0, sitemap_xml_1.element)(types_1.TagNames["news:language"], item.news.publication.language));
          this.push((0, sitemap_xml_1.ctag)(types_1.TagNames["news:publication"]));
          if (item.news.access) {
            this.push((0, sitemap_xml_1.element)(types_1.TagNames["news:access"], item.news.access));
          }
          if (item.news.genres) {
            this.push((0, sitemap_xml_1.element)(types_1.TagNames["news:genres"], item.news.genres));
          }
          this.push((0, sitemap_xml_1.element)(types_1.TagNames["news:publication_date"], item.news.publication_date));
          this.push((0, sitemap_xml_1.element)(types_1.TagNames["news:title"], item.news.title));
          if (item.news.keywords) {
            this.push((0, sitemap_xml_1.element)(types_1.TagNames["news:keywords"], item.news.keywords));
          }
          if (item.news.stock_tickers) {
            this.push((0, sitemap_xml_1.element)(types_1.TagNames["news:stock_tickers"], item.news.stock_tickers));
          }
          this.push((0, sitemap_xml_1.ctag)(types_1.TagNames["news:news"]));
        }
        item.img.forEach((image) => {
          this.push((0, sitemap_xml_1.otag)(types_1.TagNames["image:image"]));
          this.push((0, sitemap_xml_1.element)(types_1.TagNames["image:loc"], image.url));
          if (image.caption) {
            this.push((0, sitemap_xml_1.element)(types_1.TagNames["image:caption"], image.caption));
          }
          if (image.geoLocation) {
            this.push((0, sitemap_xml_1.element)(types_1.TagNames["image:geo_location"], image.geoLocation));
          }
          if (image.title) {
            this.push((0, sitemap_xml_1.element)(types_1.TagNames["image:title"], image.title));
          }
          if (image.license) {
            this.push((0, sitemap_xml_1.element)(types_1.TagNames["image:license"], image.license));
          }
          this.push((0, sitemap_xml_1.ctag)(types_1.TagNames["image:image"]));
        });
        this.push((0, sitemap_xml_1.ctag)(types_1.TagNames.url));
        callback();
      }
    };
    exports.SitemapItemStream = SitemapItemStream;
  }
});

// browser-external:readline
var require_readline = __commonJS({
  "browser-external:readline"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "readline" has been externalized for browser compatibility. Cannot access "readline.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/sitemap/dist/lib/utils.js
var require_utils = __commonJS({
  "node_modules/sitemap/dist/lib/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.normalizeURL = exports.chunk = exports.lineSeparatedURLsToSitemapOptions = exports.ReadlineStream = exports.mergeStreams = exports.validateSMIOptions = void 0;
    var fs_1 = require_fs();
    var stream_1 = require_stream();
    var readline_1 = require_readline();
    var url_1 = require_url();
    var types_1 = require_types();
    var errors_1 = require_errors();
    var types_2 = require_types();
    function validate(subject, name, url, level) {
      Object.keys(subject).forEach((key) => {
        const val = subject[key];
        if (types_2.validators[key] && !types_2.validators[key].test(val)) {
          if (level === types_1.ErrorLevel.THROW) {
            throw new errors_1.InvalidAttrValue(key, val, types_2.validators[key]);
          } else {
            console.warn(`${url}: ${name} key ${key} has invalid value: ${val}`);
          }
        }
      });
    }
    function handleError(error, level) {
      if (level === types_1.ErrorLevel.THROW) {
        throw error;
      } else if (level === types_1.ErrorLevel.WARN) {
        console.warn(error.name, error.message);
      }
    }
    function validateSMIOptions(conf, level = types_1.ErrorLevel.WARN, errorHandler = handleError) {
      if (!conf) {
        throw new errors_1.NoConfigError();
      }
      if (level === types_1.ErrorLevel.SILENT) {
        return conf;
      }
      const { url, changefreq, priority, news, video } = conf;
      if (!url) {
        errorHandler(new errors_1.NoURLError(), level);
      }
      if (changefreq) {
        if (!(0, types_1.isValidChangeFreq)(changefreq)) {
          errorHandler(new errors_1.ChangeFreqInvalidError(url, changefreq), level);
        }
      }
      if (priority) {
        if (!(priority >= 0 && priority <= 1)) {
          errorHandler(new errors_1.PriorityInvalidError(url, priority), level);
        }
      }
      if (news) {
        if (news.access && news.access !== "Registration" && news.access !== "Subscription") {
          errorHandler(new errors_1.InvalidNewsAccessValue(url, news.access), level);
        }
        if (!news.publication || !news.publication.name || !news.publication.language || !news.publication_date || !news.title) {
          errorHandler(new errors_1.InvalidNewsFormat(url), level);
        }
        validate(news, "news", url, level);
        validate(news.publication, "publication", url, level);
      }
      if (video) {
        video.forEach((vid) => {
          var _a;
          if (vid.duration !== void 0) {
            if (vid.duration < 0 || vid.duration > 28800) {
              errorHandler(new errors_1.InvalidVideoDuration(url, vid.duration), level);
            }
          }
          if (vid.rating !== void 0 && (vid.rating < 0 || vid.rating > 5)) {
            errorHandler(new errors_1.InvalidVideoRating(url, vid.title, vid.rating), level);
          }
          if (typeof vid !== "object" || !vid.thumbnail_loc || !vid.title || !vid.description) {
            errorHandler(new errors_1.InvalidVideoFormat(url), level);
          }
          if (vid.title.length > 100) {
            errorHandler(new errors_1.InvalidVideoTitle(url, vid.title.length), level);
          }
          if (vid.description.length > 2048) {
            errorHandler(new errors_1.InvalidVideoDescription(url, vid.description.length), level);
          }
          if (vid.view_count !== void 0 && vid.view_count < 0) {
            errorHandler(new errors_1.InvalidVideoViewCount(url, vid.view_count), level);
          }
          if (vid.tag.length > 32) {
            errorHandler(new errors_1.InvalidVideoTagCount(url, vid.tag.length), level);
          }
          if (vid.category !== void 0 && ((_a = vid.category) === null || _a === void 0 ? void 0 : _a.length) > 256) {
            errorHandler(new errors_1.InvalidVideoCategory(url, vid.category.length), level);
          }
          if (vid.family_friendly !== void 0 && !(0, types_1.isValidYesNo)(vid.family_friendly)) {
            errorHandler(new errors_1.InvalidVideoFamilyFriendly(url, vid.family_friendly), level);
          }
          if (vid.restriction) {
            if (!types_2.validators.restriction.test(vid.restriction)) {
              errorHandler(new errors_1.InvalidVideoRestriction(url, vid.restriction), level);
            }
            if (!vid["restriction:relationship"] || !(0, types_1.isAllowDeny)(vid["restriction:relationship"])) {
              errorHandler(new errors_1.InvalidVideoRestrictionRelationship(url, vid["restriction:relationship"]), level);
            }
          }
          if (vid.price === "" && vid["price:type"] === void 0 || vid["price:type"] !== void 0 && !(0, types_1.isPriceType)(vid["price:type"])) {
            errorHandler(new errors_1.InvalidVideoPriceType(url, vid["price:type"], vid.price), level);
          }
          if (vid["price:resolution"] !== void 0 && !(0, types_1.isResolution)(vid["price:resolution"])) {
            errorHandler(new errors_1.InvalidVideoResolution(url, vid["price:resolution"]), level);
          }
          if (vid["price:currency"] !== void 0 && !types_2.validators["price:currency"].test(vid["price:currency"])) {
            errorHandler(new errors_1.InvalidVideoPriceCurrency(url, vid["price:currency"]), level);
          }
          validate(vid, "video", url, level);
        });
      }
      return conf;
    }
    exports.validateSMIOptions = validateSMIOptions;
    function mergeStreams(streams, options) {
      let pass = new stream_1.PassThrough(options);
      let waiting = streams.length;
      for (const stream of streams) {
        pass = stream.pipe(pass, { end: false });
        stream.once("end", () => --waiting === 0 && pass.emit("end"));
      }
      return pass;
    }
    exports.mergeStreams = mergeStreams;
    var ReadlineStream = class extends stream_1.Readable {
      constructor(options) {
        if (options.autoDestroy === void 0) {
          options.autoDestroy = true;
        }
        options.objectMode = true;
        super(options);
        this._source = (0, readline_1.createInterface)({
          input: options.input,
          terminal: false,
          crlfDelay: Infinity
        });
        this._source.on("line", (chunk2) => {
          if (!this.push(chunk2))
            this._source.pause();
        });
        this._source.on("close", () => {
          this.push(null);
        });
      }
      // _read() will be called when the stream wants to pull more data in.
      // The advisory size argument is ignored in this case.
      _read(size) {
        this._source.resume();
      }
    };
    exports.ReadlineStream = ReadlineStream;
    function lineSeparatedURLsToSitemapOptions(stream, { isJSON } = {}) {
      return new ReadlineStream({ input: stream }).pipe(new stream_1.Transform({
        objectMode: true,
        // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
        transform: (line, encoding, cb) => {
          if (isJSON || isJSON === void 0 && line[0] === "{") {
            cb(null, JSON.parse(line));
          } else {
            cb(null, line);
          }
        }
      }));
    }
    exports.lineSeparatedURLsToSitemapOptions = lineSeparatedURLsToSitemapOptions;
    function chunk(array, size = 1) {
      size = Math.max(Math.trunc(size), 0);
      const length = array ? array.length : 0;
      if (!length || size < 1) {
        return [];
      }
      const result = Array(Math.ceil(length / size));
      let index = 0, resIndex = 0;
      while (index < length) {
        result[resIndex++] = array.slice(index, index += size);
      }
      return result;
    }
    exports.chunk = chunk;
    function boolToYESNO(bool) {
      if (bool === void 0) {
        return bool;
      }
      if (typeof bool === "boolean") {
        return bool ? types_1.EnumYesNo.yes : types_1.EnumYesNo.no;
      }
      return bool;
    }
    function normalizeURL(elem, hostname, lastmodDateOnly = false) {
      let smi = {
        img: [],
        video: [],
        links: [],
        url: ""
      };
      let smiLoose;
      if (typeof elem === "string") {
        smi.url = elem;
        smiLoose = { url: elem };
      } else {
        smiLoose = elem;
      }
      smi.url = new url_1.URL(smiLoose.url, hostname).toString();
      let img = [];
      if (smiLoose.img) {
        if (typeof smiLoose.img === "string") {
          smiLoose.img = [{ url: smiLoose.img }];
        } else if (!Array.isArray(smiLoose.img)) {
          smiLoose.img = [smiLoose.img];
        }
        img = smiLoose.img.map((el) => typeof el === "string" ? { url: el } : el);
      }
      smi.img = img.map((el) => ({
        ...el,
        url: new url_1.URL(el.url, hostname).toString()
      }));
      let links = [];
      if (smiLoose.links) {
        links = smiLoose.links;
      }
      smi.links = links.map((link) => {
        return { ...link, url: new url_1.URL(link.url, hostname).toString() };
      });
      if (smiLoose.video) {
        if (!Array.isArray(smiLoose.video)) {
          smiLoose.video = [smiLoose.video];
        }
        smi.video = smiLoose.video.map((video) => {
          const nv = {
            ...video,
            family_friendly: boolToYESNO(video.family_friendly),
            live: boolToYESNO(video.live),
            requires_subscription: boolToYESNO(video.requires_subscription),
            tag: [],
            rating: void 0
          };
          if (video.tag !== void 0) {
            nv.tag = !Array.isArray(video.tag) ? [video.tag] : video.tag;
          }
          if (video.rating !== void 0) {
            if (typeof video.rating === "string") {
              nv.rating = parseFloat(video.rating);
            } else {
              nv.rating = video.rating;
            }
          }
          if (typeof video.view_count === "string") {
            nv.view_count = parseInt(video.view_count, 10);
          } else if (typeof video.view_count === "number") {
            nv.view_count = video.view_count;
          }
          return nv;
        });
      }
      if (smiLoose.lastmodfile) {
        const { mtime } = (0, fs_1.statSync)(smiLoose.lastmodfile);
        smi.lastmod = new Date(mtime).toISOString();
      } else if (smiLoose.lastmodISO) {
        smi.lastmod = new Date(smiLoose.lastmodISO).toISOString();
      } else if (smiLoose.lastmod) {
        smi.lastmod = new Date(smiLoose.lastmod).toISOString();
      }
      if (lastmodDateOnly && smi.lastmod) {
        smi.lastmod = smi.lastmod.slice(0, 10);
      }
      delete smiLoose.lastmodfile;
      delete smiLoose.lastmodISO;
      smi = { ...smiLoose, ...smi };
      return smi;
    }
    exports.normalizeURL = normalizeURL;
  }
});

// node_modules/sitemap/dist/lib/sitemap-stream.js
var require_sitemap_stream = __commonJS({
  "node_modules/sitemap/dist/lib/sitemap-stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.streamToPromise = exports.SitemapStream = exports.closetag = exports.stylesheetInclude = void 0;
    var stream_1 = require_stream();
    var types_1 = require_types();
    var utils_1 = require_utils();
    var sitemap_item_stream_1 = require_sitemap_item_stream();
    var errors_1 = require_errors();
    var xmlDec = '<?xml version="1.0" encoding="UTF-8"?>';
    var stylesheetInclude = (url) => {
      return `<?xml-stylesheet type="text/xsl" href="${url}"?>`;
    };
    exports.stylesheetInclude = stylesheetInclude;
    var urlsetTagStart = '<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9"';
    var getURLSetNs = ({ news, video, image, xhtml, custom }, xslURL) => {
      let ns = xmlDec;
      if (xslURL) {
        ns += (0, exports.stylesheetInclude)(xslURL);
      }
      ns += urlsetTagStart;
      if (news) {
        ns += ' xmlns:news="http://www.google.com/schemas/sitemap-news/0.9"';
      }
      if (xhtml) {
        ns += ' xmlns:xhtml="http://www.w3.org/1999/xhtml"';
      }
      if (image) {
        ns += ' xmlns:image="http://www.google.com/schemas/sitemap-image/1.1"';
      }
      if (video) {
        ns += ' xmlns:video="http://www.google.com/schemas/sitemap-video/1.1"';
      }
      if (custom) {
        ns += " " + custom.join(" ");
      }
      return ns + ">";
    };
    exports.closetag = "</urlset>";
    var defaultXMLNS = {
      news: true,
      xhtml: true,
      image: true,
      video: true
    };
    var defaultStreamOpts = {
      xmlns: defaultXMLNS
    };
    var SitemapStream = class extends stream_1.Transform {
      constructor(opts = defaultStreamOpts) {
        opts.objectMode = true;
        super(opts);
        this.hasHeadOutput = false;
        this.hostname = opts.hostname;
        this.level = opts.level || types_1.ErrorLevel.WARN;
        this.errorHandler = opts.errorHandler;
        this.smiStream = new sitemap_item_stream_1.SitemapItemStream({ level: opts.level });
        this.smiStream.on("data", (data) => this.push(data));
        this.lastmodDateOnly = opts.lastmodDateOnly || false;
        this.xmlNS = opts.xmlns || defaultXMLNS;
        this.xslUrl = opts.xslUrl;
      }
      _transform(item, encoding, callback) {
        if (!this.hasHeadOutput) {
          this.hasHeadOutput = true;
          this.push(getURLSetNs(this.xmlNS, this.xslUrl));
        }
        this.smiStream.write((0, utils_1.validateSMIOptions)((0, utils_1.normalizeURL)(item, this.hostname, this.lastmodDateOnly), this.level, this.errorHandler));
        callback();
      }
      _flush(cb) {
        if (!this.hasHeadOutput) {
          cb(new errors_1.EmptySitemap());
        } else {
          this.push(exports.closetag);
          cb();
        }
      }
    };
    exports.SitemapStream = SitemapStream;
    function streamToPromise(stream) {
      return new Promise((resolve, reject) => {
        const drain = [];
        stream.pipe(new stream_1.Writable({
          write(chunk, enc, next) {
            drain.push(chunk);
            next();
          }
        })).on("error", reject).on("finish", () => {
          if (!drain.length) {
            reject(new errors_1.EmptyStream());
          } else {
            resolve(Buffer.concat(drain));
          }
        });
      });
    }
    exports.streamToPromise = streamToPromise;
  }
});

// node_modules/sitemap/dist/lib/sitemap-index-stream.js
var require_sitemap_index_stream = __commonJS({
  "node_modules/sitemap/dist/lib/sitemap-index-stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SitemapAndIndexStream = exports.SitemapIndexStream = exports.IndexTagNames = void 0;
    var stream_1 = require_stream();
    var types_1 = require_types();
    var sitemap_stream_1 = require_sitemap_stream();
    var sitemap_xml_1 = require_sitemap_xml();
    var IndexTagNames;
    (function(IndexTagNames2) {
      IndexTagNames2["sitemap"] = "sitemap";
      IndexTagNames2["loc"] = "loc";
      IndexTagNames2["lastmod"] = "lastmod";
    })(IndexTagNames = exports.IndexTagNames || (exports.IndexTagNames = {}));
    var xmlDec = '<?xml version="1.0" encoding="UTF-8"?>';
    var sitemapIndexTagStart = '<sitemapindex xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">';
    var closetag = "</sitemapindex>";
    var defaultStreamOpts = {};
    var SitemapIndexStream = class extends stream_1.Transform {
      constructor(opts = defaultStreamOpts) {
        var _a;
        opts.objectMode = true;
        super(opts);
        this.hasHeadOutput = false;
        this.lastmodDateOnly = opts.lastmodDateOnly || false;
        this.level = (_a = opts.level) !== null && _a !== void 0 ? _a : types_1.ErrorLevel.WARN;
        this.xslUrl = opts.xslUrl;
      }
      _transform(item, encoding, callback) {
        if (!this.hasHeadOutput) {
          this.hasHeadOutput = true;
          let stylesheet = "";
          if (this.xslUrl) {
            stylesheet = (0, sitemap_stream_1.stylesheetInclude)(this.xslUrl);
          }
          this.push(xmlDec + stylesheet + sitemapIndexTagStart);
        }
        this.push((0, sitemap_xml_1.otag)(IndexTagNames.sitemap));
        if (typeof item === "string") {
          this.push((0, sitemap_xml_1.element)(IndexTagNames.loc, item));
        } else {
          this.push((0, sitemap_xml_1.element)(IndexTagNames.loc, item.url));
          if (item.lastmod) {
            const lastmod = new Date(item.lastmod).toISOString();
            this.push((0, sitemap_xml_1.element)(IndexTagNames.lastmod, this.lastmodDateOnly ? lastmod.slice(0, 10) : lastmod));
          }
        }
        this.push((0, sitemap_xml_1.ctag)(IndexTagNames.sitemap));
        callback();
      }
      _flush(cb) {
        this.push(closetag);
        cb();
      }
    };
    exports.SitemapIndexStream = SitemapIndexStream;
    var SitemapAndIndexStream = class extends SitemapIndexStream {
      constructor(opts) {
        var _a;
        opts.objectMode = true;
        super(opts);
        this.i = 0;
        this.getSitemapStream = opts.getSitemapStream;
        [this.idxItem, this.currentSitemap, this.currentSitemapPipeline] = this.getSitemapStream(0);
        this.limit = (_a = opts.limit) !== null && _a !== void 0 ? _a : 45e3;
      }
      _writeSMI(item) {
        this.currentSitemap.write(item);
        this.i++;
      }
      _transform(item, encoding, callback) {
        var _a;
        if (this.i === 0) {
          this._writeSMI(item);
          super._transform(this.idxItem, encoding, callback);
        } else if (this.i % this.limit === 0) {
          const onFinish = () => {
            const [idxItem, currentSitemap, currentSitemapPipeline] = this.getSitemapStream(this.i / this.limit);
            this.currentSitemap = currentSitemap;
            this.currentSitemapPipeline = currentSitemapPipeline;
            this._writeSMI(item);
            super._transform(idxItem, encoding, callback);
          };
          (_a = this.currentSitemapPipeline) === null || _a === void 0 ? void 0 : _a.on("finish", onFinish);
          this.currentSitemap.end(!this.currentSitemapPipeline ? onFinish : void 0);
        } else {
          this._writeSMI(item);
          callback();
        }
      }
      _flush(cb) {
        var _a;
        const onFinish = () => super._flush(cb);
        (_a = this.currentSitemapPipeline) === null || _a === void 0 ? void 0 : _a.on("finish", onFinish);
        this.currentSitemap.end(!this.currentSitemapPipeline ? onFinish : void 0);
      }
    };
    exports.SitemapAndIndexStream = SitemapAndIndexStream;
  }
});

// browser-external:child_process
var require_child_process = __commonJS({
  "browser-external:child_process"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "child_process" has been externalized for browser compatibility. Cannot access "child_process.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/sitemap/dist/lib/xmllint.js
var require_xmllint = __commonJS({
  "node_modules/sitemap/dist/lib/xmllint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.xmlLint = void 0;
    var path_1 = require_path();
    var child_process_1 = require_child_process();
    var errors_1 = require_errors();
    function xmlLint(xml) {
      const args = [
        "--schema",
        (0, path_1.resolve)(__dirname, "..", "..", "schema", "all.xsd"),
        "--noout",
        "-"
      ];
      if (typeof xml === "string") {
        args[args.length - 1] = xml;
      }
      return new Promise((resolve, reject) => {
        (0, child_process_1.execFile)("which", ["xmllint"], (error, stdout, stderr) => {
          if (error) {
            reject([new errors_1.XMLLintUnavailable()]);
            return;
          }
          const xmllint = (0, child_process_1.execFile)("xmllint", args, (error2, stdout2, stderr2) => {
            if (error2) {
              reject([error2, stderr2]);
            }
            resolve();
          });
          if (xmllint.stdout) {
            xmllint.stdout.unpipe();
            if (typeof xml !== "string" && xml && xmllint.stdin) {
              xml.pipe(xmllint.stdin);
            }
          }
        });
      });
    }
    exports.xmlLint = xmlLint;
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      var b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(
          value[Symbol.toPrimitive]("string"),
          encodingOrOffset,
          length
        );
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length = byteLength(string, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);
      for (var i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b)
        return 0;
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      var i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer = Buffer2.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            Buffer2.from(buf).copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      var len = string.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      var length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b) {
      if (!Buffer2.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      var str = "";
      var max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      var strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer2.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      var out = "";
      for (var i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = "";
      for (var i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var i = byteLength2;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      var alphabet = "0123456789abcdef";
      var table = new Array(256);
      for (var i = 0; i < 16; ++i) {
        var i16 = i * 16;
        for (var j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
  }
});

// node_modules/string_decoder/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/string_decoder/node_modules/safe-buffer/index.js"(exports, module) {
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self.lastNeed = 0;
        return "�";
      }
      if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self.lastNeed = 1;
          return "�";
        }
        if (self.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self.lastNeed = 2;
            return "�";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "�";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/sax/lib/sax.js
var require_sax = __commonJS({
  "node_modules/sax/lib/sax.js"(exports) {
    (function(sax) {
      sax.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax.SAXParser = SAXParser;
      sax.SAXStream = SAXStream;
      sax.createStream = createStream;
      sax.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) {
          parser.ns = Object.create(rootNS);
        }
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit(parser, "onready");
      }
      if (!Object.create) {
        Object.create = function(o) {
          function F() {
          }
          F.prototype = o;
          var newf = new F();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function(o) {
          var a = [];
          for (var i in o)
            if (o.hasOwnProperty(i))
              a.push(i);
          return a;
        };
      }
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i = 0, l = buffers.length; i < l; i++) {
          var len = parser[buffers[i]].length;
          if (len > maxAllowed) {
            switch (buffers[i]) {
              case "textNode":
                closeText(parser);
                break;
              case "cdata":
                emitNode(parser, "oncdata", parser.cdata);
                parser.cdata = "";
                break;
              case "script":
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
                break;
              default:
                error(parser, "Max buffer length exceeded: " + buffers[i]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        var m = sax.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
      }
      function clearBuffers(parser) {
        for (var i = 0, l = buffers.length; i < l; i++) {
          parser[buffers[i]] = "";
        }
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var Stream;
      try {
        Stream = require_stream().Stream;
      } catch (ex) {
        Stream = function() {
        };
      }
      var streamWraps = sax.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
          return new SAXStream(strict, opt);
        }
        Stream.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
          me.emit("end");
        };
        this._parser.onerror = function(er) {
          me.emit("error", er);
          me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
          Object.defineProperty(me, "on" + ev, {
            get: function() {
              return me._parser["on" + ev];
            },
            set: function(h) {
              if (!h) {
                me.removeAllListeners(ev);
                me._parser["on" + ev] = h;
                return h;
              }
              me.on(ev, h);
            },
            enumerable: true,
            configurable: false
          });
        });
      }
      SAXStream.prototype = Object.create(Stream.prototype, {
        constructor: {
          value: SAXStream
        }
      });
      SAXStream.prototype.write = function(data) {
        if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
          if (!this._decoder) {
            var SD = require_string_decoder().StringDecoder;
            this._decoder = new SD("utf8");
          }
          data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit("data", data);
        return true;
      };
      SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) {
          this.write(chunk);
        }
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
          me._parser["on" + ev] = function() {
            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
          };
        }
        return Stream.prototype.on.call(me, ev, handler);
      };
      var CDATA = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace(c) {
        return c === " " || c === "\n" || c === "\r" || c === "	";
      }
      function isQuote(c) {
        return c === '"' || c === "'";
      }
      function isAttribEnd(c) {
        return c === ">" || isWhitespace(c);
      }
      function isMatch(regex, c) {
        return regex.test(c);
      }
      function notMatch(regex, c) {
        return !isMatch(regex, c);
      }
      var S = 0;
      sax.STATE = {
        BEGIN: S++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: S++,
        // leading whitespace
        TEXT: S++,
        // general stuff
        TEXT_ENTITY: S++,
        // &amp and such.
        OPEN_WAKA: S++,
        // <
        SGML_DECL: S++,
        // <!BLARG
        SGML_DECL_QUOTED: S++,
        // <!BLARG foo "bar
        DOCTYPE: S++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: S++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: S++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: S++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: S++,
        // <!-
        COMMENT: S++,
        // <!--
        COMMENT_ENDING: S++,
        // <!-- blah -
        COMMENT_ENDED: S++,
        // <!-- blah --
        CDATA: S++,
        // <![CDATA[ something
        CDATA_ENDING: S++,
        // ]
        CDATA_ENDING_2: S++,
        // ]]
        PROC_INST: S++,
        // <?hi
        PROC_INST_BODY: S++,
        // <?hi there
        PROC_INST_ENDING: S++,
        // <?hi "there" ?
        OPEN_TAG: S++,
        // <strong
        OPEN_TAG_SLASH: S++,
        // <strong /
        ATTRIB: S++,
        // <a
        ATTRIB_NAME: S++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: S++,
        // <a foo _
        ATTRIB_VALUE: S++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: S++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: S++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: S++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: S++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: S++,
        // <foo bar=&quot
        CLOSE_TAG: S++,
        // </a
        CLOSE_TAG_SAW_WHITE: S++,
        // </a   >
        SCRIPT: S++,
        // <script> ...
        SCRIPT_ENDING: S++
        // <script> ... <
      };
      sax.XML_ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'"
      };
      sax.ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'",
        "AElig": 198,
        "Aacute": 193,
        "Acirc": 194,
        "Agrave": 192,
        "Aring": 197,
        "Atilde": 195,
        "Auml": 196,
        "Ccedil": 199,
        "ETH": 208,
        "Eacute": 201,
        "Ecirc": 202,
        "Egrave": 200,
        "Euml": 203,
        "Iacute": 205,
        "Icirc": 206,
        "Igrave": 204,
        "Iuml": 207,
        "Ntilde": 209,
        "Oacute": 211,
        "Ocirc": 212,
        "Ograve": 210,
        "Oslash": 216,
        "Otilde": 213,
        "Ouml": 214,
        "THORN": 222,
        "Uacute": 218,
        "Ucirc": 219,
        "Ugrave": 217,
        "Uuml": 220,
        "Yacute": 221,
        "aacute": 225,
        "acirc": 226,
        "aelig": 230,
        "agrave": 224,
        "aring": 229,
        "atilde": 227,
        "auml": 228,
        "ccedil": 231,
        "eacute": 233,
        "ecirc": 234,
        "egrave": 232,
        "eth": 240,
        "euml": 235,
        "iacute": 237,
        "icirc": 238,
        "igrave": 236,
        "iuml": 239,
        "ntilde": 241,
        "oacute": 243,
        "ocirc": 244,
        "ograve": 242,
        "oslash": 248,
        "otilde": 245,
        "ouml": 246,
        "szlig": 223,
        "thorn": 254,
        "uacute": 250,
        "ucirc": 251,
        "ugrave": 249,
        "uuml": 252,
        "yacute": 253,
        "yuml": 255,
        "copy": 169,
        "reg": 174,
        "nbsp": 160,
        "iexcl": 161,
        "cent": 162,
        "pound": 163,
        "curren": 164,
        "yen": 165,
        "brvbar": 166,
        "sect": 167,
        "uml": 168,
        "ordf": 170,
        "laquo": 171,
        "not": 172,
        "shy": 173,
        "macr": 175,
        "deg": 176,
        "plusmn": 177,
        "sup1": 185,
        "sup2": 178,
        "sup3": 179,
        "acute": 180,
        "micro": 181,
        "para": 182,
        "middot": 183,
        "cedil": 184,
        "ordm": 186,
        "raquo": 187,
        "frac14": 188,
        "frac12": 189,
        "frac34": 190,
        "iquest": 191,
        "times": 215,
        "divide": 247,
        "OElig": 338,
        "oelig": 339,
        "Scaron": 352,
        "scaron": 353,
        "Yuml": 376,
        "fnof": 402,
        "circ": 710,
        "tilde": 732,
        "Alpha": 913,
        "Beta": 914,
        "Gamma": 915,
        "Delta": 916,
        "Epsilon": 917,
        "Zeta": 918,
        "Eta": 919,
        "Theta": 920,
        "Iota": 921,
        "Kappa": 922,
        "Lambda": 923,
        "Mu": 924,
        "Nu": 925,
        "Xi": 926,
        "Omicron": 927,
        "Pi": 928,
        "Rho": 929,
        "Sigma": 931,
        "Tau": 932,
        "Upsilon": 933,
        "Phi": 934,
        "Chi": 935,
        "Psi": 936,
        "Omega": 937,
        "alpha": 945,
        "beta": 946,
        "gamma": 947,
        "delta": 948,
        "epsilon": 949,
        "zeta": 950,
        "eta": 951,
        "theta": 952,
        "iota": 953,
        "kappa": 954,
        "lambda": 955,
        "mu": 956,
        "nu": 957,
        "xi": 958,
        "omicron": 959,
        "pi": 960,
        "rho": 961,
        "sigmaf": 962,
        "sigma": 963,
        "tau": 964,
        "upsilon": 965,
        "phi": 966,
        "chi": 967,
        "psi": 968,
        "omega": 969,
        "thetasym": 977,
        "upsih": 978,
        "piv": 982,
        "ensp": 8194,
        "emsp": 8195,
        "thinsp": 8201,
        "zwnj": 8204,
        "zwj": 8205,
        "lrm": 8206,
        "rlm": 8207,
        "ndash": 8211,
        "mdash": 8212,
        "lsquo": 8216,
        "rsquo": 8217,
        "sbquo": 8218,
        "ldquo": 8220,
        "rdquo": 8221,
        "bdquo": 8222,
        "dagger": 8224,
        "Dagger": 8225,
        "bull": 8226,
        "hellip": 8230,
        "permil": 8240,
        "prime": 8242,
        "Prime": 8243,
        "lsaquo": 8249,
        "rsaquo": 8250,
        "oline": 8254,
        "frasl": 8260,
        "euro": 8364,
        "image": 8465,
        "weierp": 8472,
        "real": 8476,
        "trade": 8482,
        "alefsym": 8501,
        "larr": 8592,
        "uarr": 8593,
        "rarr": 8594,
        "darr": 8595,
        "harr": 8596,
        "crarr": 8629,
        "lArr": 8656,
        "uArr": 8657,
        "rArr": 8658,
        "dArr": 8659,
        "hArr": 8660,
        "forall": 8704,
        "part": 8706,
        "exist": 8707,
        "empty": 8709,
        "nabla": 8711,
        "isin": 8712,
        "notin": 8713,
        "ni": 8715,
        "prod": 8719,
        "sum": 8721,
        "minus": 8722,
        "lowast": 8727,
        "radic": 8730,
        "prop": 8733,
        "infin": 8734,
        "ang": 8736,
        "and": 8743,
        "or": 8744,
        "cap": 8745,
        "cup": 8746,
        "int": 8747,
        "there4": 8756,
        "sim": 8764,
        "cong": 8773,
        "asymp": 8776,
        "ne": 8800,
        "equiv": 8801,
        "le": 8804,
        "ge": 8805,
        "sub": 8834,
        "sup": 8835,
        "nsub": 8836,
        "sube": 8838,
        "supe": 8839,
        "oplus": 8853,
        "otimes": 8855,
        "perp": 8869,
        "sdot": 8901,
        "lceil": 8968,
        "rceil": 8969,
        "lfloor": 8970,
        "rfloor": 8971,
        "lang": 9001,
        "rang": 9002,
        "loz": 9674,
        "spades": 9824,
        "clubs": 9827,
        "hearts": 9829,
        "diams": 9830
      };
      Object.keys(sax.ENTITIES).forEach(function(key) {
        var e = sax.ENTITIES[key];
        var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
        sax.ENTITIES[key] = s2;
      });
      for (var s in sax.STATE) {
        sax.STATE[sax.STATE[s]] = s;
      }
      S = sax.STATE;
      function emit(parser, event, data) {
        parser[event] && parser[event](data);
      }
      function emitNode(parser, nodeType, data) {
        if (parser.textNode)
          closeText(parser);
        emit(parser, nodeType, data);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode)
          emit(parser, "ontext", parser.textNode);
        parser.textNode = "";
      }
      function textopts(opt, text) {
        if (opt.trim)
          text = text.trim();
        if (opt.normalize)
          text = text.replace(/\s+/g, " ");
        return text;
      }
      function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
          er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit(parser, "onerror", er);
        return parser;
      }
      function end(parser) {
        if (parser.sawRoot && !parser.closedRoot)
          strictFail(parser, "Unclosed root tag");
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
          error(parser, "Unexpected end");
        }
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      function strictFail(parser, message) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
          throw new Error("bad call to strictFail");
        }
        if (parser.strict) {
          error(parser, message);
        }
      }
      function newTag(parser) {
        if (!parser.strict)
          parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = { name: parser.tagName, attributes: {} };
        if (parser.opt.xmlns) {
          tag.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag);
      }
      function qname(name, attribute) {
        var i = name.indexOf(":");
        var qualName = i < 0 ? ["", name] : name.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return { prefix, local };
      }
      function attrib(parser) {
        if (!parser.strict) {
          parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = "";
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === "xmlns") {
            if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
              strictFail(
                parser,
                "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
              strictFail(
                parser,
                "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else {
              var tag = parser.tag;
              var parent = parser.tags[parser.tags.length - 1] || parser;
              if (tag.ns === parent.ns) {
                tag.ns = Object.create(parent.ns);
              }
              tag.ns[local] = parser.attribValue;
            }
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = "";
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag = parser.tag;
          var qn = qname(parser.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
            tag.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns && parent.ns !== tag.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              emitNode(parser, "onopennamespace", {
                prefix: p,
                uri: tag.ns[p]
              });
            });
          }
          for (var i = 0, l = parser.attribList.length; i < l; i++) {
            var nv = parser.attribList[i];
            var name = nv[0];
            var value = nv[1];
            var qualName = qname(name, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri = prefix === "" ? "" : tag.ns[prefix] || "";
            var a = {
              name,
              value,
              prefix,
              local,
              uri
            };
            if (prefix && prefix !== "xmlns" && !uri) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
              a.uri = prefix;
            }
            parser.tag.attributes[name] = a;
            emitNode(parser, "onattribute", a);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
            parser.state = S.SCRIPT;
          } else {
            parser.state = S.TEXT;
          }
          parser.tag = null;
          parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag.");
          parser.textNode += "</>";
          parser.state = S.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">";
            parser.tagName = "";
            parser.state = S.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
          tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while (t--) {
          var close = parser.tags[t];
          if (close.name !== closeTo) {
            strictFail(parser, "Unexpected close tag");
          } else {
            break;
          }
        }
        if (t < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName);
          parser.textNode += "</" + parser.tagName + ">";
          parser.state = S.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s2 = parser.tags.length;
        while (s2-- > t) {
          var tag = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, "onclosetag", parser.tagName);
          var x = {};
          for (var i in tag.ns) {
            x[i] = tag.ns[i];
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag.ns !== parent.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              var n = tag.ns[p];
              emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
            });
          }
        }
        if (t === 0)
          parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) {
          return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
          return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
          strictFail(parser, "Invalid character entity");
          return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser, c) {
        if (c === "<") {
          parser.state = S.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c)) {
          strictFail(parser, "Non-whitespace before first tag.");
          parser.textNode = c;
          parser.state = S.TEXT;
        }
      }
      function charAt(chunk, i) {
        var result = "";
        if (i < chunk.length) {
          result = chunk.charAt(i);
        }
        return result;
      }
      function write(chunk) {
        var parser = this;
        if (this.error) {
          throw this.error;
        }
        if (parser.closed) {
          return error(
            parser,
            "Cannot write after close. Assign an onready handler."
          );
        }
        if (chunk === null) {
          return end(parser);
        }
        if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        var i = 0;
        var c = "";
        while (true) {
          c = charAt(chunk, i++);
          parser.c = c;
          if (!c) {
            break;
          }
          if (parser.trackPosition) {
            parser.position++;
            if (c === "\n") {
              parser.line++;
              parser.column = 0;
            } else {
              parser.column++;
            }
          }
          switch (parser.state) {
            case S.BEGIN:
              parser.state = S.BEGIN_WHITESPACE;
              if (c === "\uFEFF") {
                continue;
              }
              beginWhiteSpace(parser, c);
              continue;
            case S.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c);
              continue;
            case S.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i - 1;
                while (c && c !== "<" && c !== "&") {
                  c = charAt(chunk, i++);
                  if (c && parser.trackPosition) {
                    parser.position++;
                    if (c === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                }
                parser.textNode += chunk.substring(starti, i - 1);
              }
              if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                  strictFail(parser, "Text data outside of root node.");
                }
                if (c === "&") {
                  parser.state = S.TEXT_ENTITY;
                } else {
                  parser.textNode += c;
                }
              }
              continue;
            case S.SCRIPT:
              if (c === "<") {
                parser.state = S.SCRIPT_ENDING;
              } else {
                parser.script += c;
              }
              continue;
            case S.SCRIPT_ENDING:
              if (c === "/") {
                parser.state = S.CLOSE_TAG;
              } else {
                parser.script += "<" + c;
                parser.state = S.SCRIPT;
              }
              continue;
            case S.OPEN_WAKA:
              if (c === "!") {
                parser.state = S.SGML_DECL;
                parser.sgmlDecl = "";
              } else if (isWhitespace(c)) {
              } else if (isMatch(nameStart, c)) {
                parser.state = S.OPEN_TAG;
                parser.tagName = c;
              } else if (c === "/") {
                parser.state = S.CLOSE_TAG;
                parser.tagName = "";
              } else if (c === "?") {
                parser.state = S.PROC_INST;
                parser.procInstName = parser.procInstBody = "";
              } else {
                strictFail(parser, "Unencoded <");
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c = new Array(pad).join(" ") + c;
                }
                parser.textNode += "<" + c;
                parser.state = S.TEXT;
              }
              continue;
            case S.SGML_DECL:
              if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                emitNode(parser, "onopencdata");
                parser.state = S.CDATA;
                parser.sgmlDecl = "";
                parser.cdata = "";
              } else if (parser.sgmlDecl + c === "--") {
                parser.state = S.COMMENT;
                parser.comment = "";
                parser.sgmlDecl = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                parser.state = S.DOCTYPE;
                if (parser.doctype || parser.sawRoot) {
                  strictFail(
                    parser,
                    "Inappropriately located doctype declaration"
                  );
                }
                parser.doctype = "";
                parser.sgmlDecl = "";
              } else if (c === ">") {
                emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                parser.sgmlDecl = "";
                parser.state = S.TEXT;
              } else if (isQuote(c)) {
                parser.state = S.SGML_DECL_QUOTED;
                parser.sgmlDecl += c;
              } else {
                parser.sgmlDecl += c;
              }
              continue;
            case S.SGML_DECL_QUOTED:
              if (c === parser.q) {
                parser.state = S.SGML_DECL;
                parser.q = "";
              }
              parser.sgmlDecl += c;
              continue;
            case S.DOCTYPE:
              if (c === ">") {
                parser.state = S.TEXT;
                emitNode(parser, "ondoctype", parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c;
                if (c === "[") {
                  parser.state = S.DOCTYPE_DTD;
                } else if (isQuote(c)) {
                  parser.state = S.DOCTYPE_QUOTED;
                  parser.q = c;
                }
              }
              continue;
            case S.DOCTYPE_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.q = "";
                parser.state = S.DOCTYPE;
              }
              continue;
            case S.DOCTYPE_DTD:
              parser.doctype += c;
              if (c === "]") {
                parser.state = S.DOCTYPE;
              } else if (isQuote(c)) {
                parser.state = S.DOCTYPE_DTD_QUOTED;
                parser.q = c;
              }
              continue;
            case S.DOCTYPE_DTD_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.state = S.DOCTYPE_DTD;
                parser.q = "";
              }
              continue;
            case S.COMMENT:
              if (c === "-") {
                parser.state = S.COMMENT_ENDING;
              } else {
                parser.comment += c;
              }
              continue;
            case S.COMMENT_ENDING:
              if (c === "-") {
                parser.state = S.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) {
                  emitNode(parser, "oncomment", parser.comment);
                }
                parser.comment = "";
              } else {
                parser.comment += "-" + c;
                parser.state = S.COMMENT;
              }
              continue;
            case S.COMMENT_ENDED:
              if (c !== ">") {
                strictFail(parser, "Malformed comment");
                parser.comment += "--" + c;
                parser.state = S.COMMENT;
              } else {
                parser.state = S.TEXT;
              }
              continue;
            case S.CDATA:
              if (c === "]") {
                parser.state = S.CDATA_ENDING;
              } else {
                parser.cdata += c;
              }
              continue;
            case S.CDATA_ENDING:
              if (c === "]") {
                parser.state = S.CDATA_ENDING_2;
              } else {
                parser.cdata += "]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.CDATA_ENDING_2:
              if (c === ">") {
                if (parser.cdata) {
                  emitNode(parser, "oncdata", parser.cdata);
                }
                emitNode(parser, "onclosecdata");
                parser.cdata = "";
                parser.state = S.TEXT;
              } else if (c === "]") {
                parser.cdata += "]";
              } else {
                parser.cdata += "]]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.PROC_INST:
              if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else if (isWhitespace(c)) {
                parser.state = S.PROC_INST_BODY;
              } else {
                parser.procInstName += c;
              }
              continue;
            case S.PROC_INST_BODY:
              if (!parser.procInstBody && isWhitespace(c)) {
                continue;
              } else if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else {
                parser.procInstBody += c;
              }
              continue;
            case S.PROC_INST_ENDING:
              if (c === ">") {
                emitNode(parser, "onprocessinginstruction", {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = "";
                parser.state = S.TEXT;
              } else {
                parser.procInstBody += "?" + c;
                parser.state = S.PROC_INST_BODY;
              }
              continue;
            case S.OPEN_TAG:
              if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else {
                newTag(parser);
                if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else {
                  if (!isWhitespace(c)) {
                    strictFail(parser, "Invalid character in tag name");
                  }
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.OPEN_TAG_SLASH:
              if (c === ">") {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(parser, "Forward-slash in opening tag not followed by >");
                parser.state = S.ATTRIB;
              }
              continue;
            case S.ATTRIB:
              if (isWhitespace(c)) {
                continue;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (c === ">") {
                strictFail(parser, "Attribute without value");
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (isWhitespace(c)) {
                parser.state = S.ATTRIB_NAME_SAW_WHITE;
              } else if (isMatch(nameBody, c)) {
                parser.attribName += c;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME_SAW_WHITE:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (isWhitespace(c)) {
                continue;
              } else {
                strictFail(parser, "Attribute without value");
                parser.tag.attributes[parser.attribName] = "";
                parser.attribValue = "";
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                });
                parser.attribName = "";
                if (c === ">") {
                  openTag(parser);
                } else if (isMatch(nameStart, c)) {
                  parser.attribName = c;
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.ATTRIB_VALUE:
              if (isWhitespace(c)) {
                continue;
              } else if (isQuote(c)) {
                parser.q = c;
                parser.state = S.ATTRIB_VALUE_QUOTED;
              } else {
                strictFail(parser, "Unquoted attribute value");
                parser.state = S.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c;
              }
              continue;
            case S.ATTRIB_VALUE_QUOTED:
              if (c !== parser.q) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              parser.q = "";
              parser.state = S.ATTRIB_VALUE_CLOSED;
              continue;
            case S.ATTRIB_VALUE_CLOSED:
              if (isWhitespace(c)) {
                parser.state = S.ATTRIB;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                strictFail(parser, "No whitespace between attributes");
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c)) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              if (c === ">") {
                openTag(parser);
              } else {
                parser.state = S.ATTRIB;
              }
              continue;
            case S.CLOSE_TAG:
              if (!parser.tagName) {
                if (isWhitespace(c)) {
                  continue;
                } else if (notMatch(nameStart, c)) {
                  if (parser.script) {
                    parser.script += "</" + c;
                    parser.state = S.SCRIPT;
                  } else {
                    strictFail(parser, "Invalid tagname in closing tag.");
                  }
                } else {
                  parser.tagName = c;
                }
              } else if (c === ">") {
                closeTag(parser);
              } else if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else if (parser.script) {
                parser.script += "</" + parser.tagName;
                parser.tagName = "";
                parser.state = S.SCRIPT;
              } else {
                if (!isWhitespace(c)) {
                  strictFail(parser, "Invalid tagname in closing tag");
                }
                parser.state = S.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace(c)) {
                continue;
              }
              if (c === ">") {
                closeTag(parser);
              } else {
                strictFail(parser, "Invalid characters in closing tag");
              }
              continue;
            case S.TEXT_ENTITY:
            case S.ATTRIB_VALUE_ENTITY_Q:
            case S.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer;
              switch (parser.state) {
                case S.TEXT_ENTITY:
                  returnState = S.TEXT;
                  buffer = "textNode";
                  break;
                case S.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S.ATTRIB_VALUE_QUOTED;
                  buffer = "attribValue";
                  break;
                case S.ATTRIB_VALUE_ENTITY_U:
                  returnState = S.ATTRIB_VALUE_UNQUOTED;
                  buffer = "attribValue";
                  break;
              }
              if (c === ";") {
                parser[buffer] += parseEntity(parser);
                parser.entity = "";
                parser.state = returnState;
              } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                parser.entity += c;
              } else {
                strictFail(parser, "Invalid character in entity name");
                parser[buffer] += "&" + parser.entity + c;
                parser.entity = "";
                parser.state = returnState;
              }
              continue;
            default:
              throw new Error(parser, "Unknown state: " + parser.state);
          }
        }
        if (parser.position >= parser.bufferCheckPosition) {
          checkBufferLength(parser);
        }
        return parser;
      }
      if (!String.fromCodePoint) {
        (function() {
          var stringFromCharCode = String.fromCharCode;
          var floor = Math.floor;
          var fromCodePoint = function() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index = -1;
            var length = arguments.length;
            if (!length) {
              return "";
            }
            var result = "";
            while (++index < length) {
              var codePoint = Number(arguments[index]);
              if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
              codePoint < 0 || // not a valid Unicode code point
              codePoint > 1114111 || // not a valid Unicode code point
              floor(codePoint) !== codePoint) {
                throw RangeError("Invalid code point: " + codePoint);
              }
              if (codePoint <= 65535) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 65536;
                highSurrogate = (codePoint >> 10) + 55296;
                lowSurrogate = codePoint % 1024 + 56320;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          };
          if (Object.defineProperty) {
            Object.defineProperty(String, "fromCodePoint", {
              value: fromCodePoint,
              configurable: true,
              writable: true
            });
          } else {
            String.fromCodePoint = fromCodePoint;
          }
        })();
      }
    })(typeof exports === "undefined" ? exports.sax = {} : exports);
  }
});

// node_modules/sitemap/dist/lib/sitemap-parser.js
var require_sitemap_parser = __commonJS({
  "node_modules/sitemap/dist/lib/sitemap-parser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ObjectStreamToJSON = exports.parseSitemap = exports.XMLToSitemapItemStream = void 0;
    var sax_1 = __importDefault(require_sax());
    var stream_1 = require_stream();
    var types_1 = require_types();
    function isValidTagName(tagName) {
      return tagName in types_1.TagNames;
    }
    function tagTemplate() {
      return {
        img: [],
        video: [],
        links: [],
        url: ""
      };
    }
    function videoTemplate() {
      return {
        tag: [],
        thumbnail_loc: "",
        title: "",
        description: ""
      };
    }
    var imageTemplate = {
      url: ""
    };
    var linkTemplate = {
      lang: "",
      url: ""
    };
    function newsTemplate() {
      return {
        publication: { name: "", language: "" },
        publication_date: "",
        title: ""
      };
    }
    var defaultLogger = (level, ...message) => console[level](...message);
    var defaultStreamOpts = {
      logger: defaultLogger
    };
    var XMLToSitemapItemStream = class extends stream_1.Transform {
      constructor(opts = defaultStreamOpts) {
        var _a;
        opts.objectMode = true;
        super(opts);
        this.error = null;
        this.saxStream = sax_1.default.createStream(true, {
          xmlns: true,
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          strictEntities: true,
          trim: true
        });
        this.level = opts.level || types_1.ErrorLevel.WARN;
        if (this.level !== types_1.ErrorLevel.SILENT && opts.logger !== false) {
          this.logger = (_a = opts.logger) !== null && _a !== void 0 ? _a : defaultLogger;
        } else {
          this.logger = () => void 0;
        }
        let currentItem = tagTemplate();
        let currentTag;
        let currentVideo = videoTemplate();
        let currentImage = { ...imageTemplate };
        let currentLink = { ...linkTemplate };
        let dontpushCurrentLink = false;
        this.saxStream.on("opentagstart", (tag) => {
          currentTag = tag.name;
          if (currentTag.startsWith("news:") && !currentItem.news) {
            currentItem.news = newsTemplate();
          }
        });
        this.saxStream.on("opentag", (tag) => {
          if (isValidTagName(tag.name)) {
            if (tag.name === "xhtml:link") {
              if (typeof tag.attributes.rel === "string" || typeof tag.attributes.href === "string") {
                return;
              }
              if (tag.attributes.rel.value === "alternate" && tag.attributes.hreflang) {
                currentLink.url = tag.attributes.href.value;
                if (typeof tag.attributes.hreflang === "string")
                  return;
                currentLink.lang = tag.attributes.hreflang.value;
              } else if (tag.attributes.rel.value === "alternate") {
                dontpushCurrentLink = true;
                currentItem.androidLink = tag.attributes.href.value;
              } else if (tag.attributes.rel.value === "amphtml") {
                dontpushCurrentLink = true;
                currentItem.ampLink = tag.attributes.href.value;
              } else {
                this.logger("log", "unhandled attr for xhtml:link", tag.attributes);
                this.err(`unhandled attr for xhtml:link ${tag.attributes}`);
              }
            }
          } else {
            this.logger("warn", "unhandled tag", tag.name);
            this.err(`unhandled tag: ${tag.name}`);
          }
        });
        this.saxStream.on("text", (text) => {
          switch (currentTag) {
            case "mobile:mobile":
              break;
            case types_1.TagNames.loc:
              currentItem.url = text;
              break;
            case types_1.TagNames.changefreq:
              if ((0, types_1.isValidChangeFreq)(text)) {
                currentItem.changefreq = text;
              }
              break;
            case types_1.TagNames.priority:
              currentItem.priority = parseFloat(text);
              break;
            case types_1.TagNames.lastmod:
              currentItem.lastmod = text;
              break;
            case types_1.TagNames["video:thumbnail_loc"]:
              currentVideo.thumbnail_loc = text;
              break;
            case types_1.TagNames["video:tag"]:
              currentVideo.tag.push(text);
              break;
            case types_1.TagNames["video:duration"]:
              currentVideo.duration = parseInt(text, 10);
              break;
            case types_1.TagNames["video:player_loc"]:
              currentVideo.player_loc = text;
              break;
            case types_1.TagNames["video:content_loc"]:
              currentVideo.content_loc = text;
              break;
            case types_1.TagNames["video:requires_subscription"]:
              if ((0, types_1.isValidYesNo)(text)) {
                currentVideo.requires_subscription = text;
              }
              break;
            case types_1.TagNames["video:publication_date"]:
              currentVideo.publication_date = text;
              break;
            case types_1.TagNames["video:id"]:
              currentVideo.id = text;
              break;
            case types_1.TagNames["video:restriction"]:
              currentVideo.restriction = text;
              break;
            case types_1.TagNames["video:view_count"]:
              currentVideo.view_count = parseInt(text, 10);
              break;
            case types_1.TagNames["video:uploader"]:
              currentVideo.uploader = text;
              break;
            case types_1.TagNames["video:family_friendly"]:
              if ((0, types_1.isValidYesNo)(text)) {
                currentVideo.family_friendly = text;
              }
              break;
            case types_1.TagNames["video:expiration_date"]:
              currentVideo.expiration_date = text;
              break;
            case types_1.TagNames["video:platform"]:
              currentVideo.platform = text;
              break;
            case types_1.TagNames["video:price"]:
              currentVideo.price = text;
              break;
            case types_1.TagNames["video:rating"]:
              currentVideo.rating = parseFloat(text);
              break;
            case types_1.TagNames["video:category"]:
              currentVideo.category = text;
              break;
            case types_1.TagNames["video:live"]:
              if ((0, types_1.isValidYesNo)(text)) {
                currentVideo.live = text;
              }
              break;
            case types_1.TagNames["video:gallery_loc"]:
              currentVideo.gallery_loc = text;
              break;
            case types_1.TagNames["image:loc"]:
              currentImage.url = text;
              break;
            case types_1.TagNames["image:geo_location"]:
              currentImage.geoLocation = text;
              break;
            case types_1.TagNames["image:license"]:
              currentImage.license = text;
              break;
            case types_1.TagNames["news:access"]:
              if (!currentItem.news) {
                currentItem.news = newsTemplate();
              }
              currentItem.news.access = text;
              break;
            case types_1.TagNames["news:genres"]:
              if (!currentItem.news) {
                currentItem.news = newsTemplate();
              }
              currentItem.news.genres = text;
              break;
            case types_1.TagNames["news:publication_date"]:
              if (!currentItem.news) {
                currentItem.news = newsTemplate();
              }
              currentItem.news.publication_date = text;
              break;
            case types_1.TagNames["news:keywords"]:
              if (!currentItem.news) {
                currentItem.news = newsTemplate();
              }
              currentItem.news.keywords = text;
              break;
            case types_1.TagNames["news:stock_tickers"]:
              if (!currentItem.news) {
                currentItem.news = newsTemplate();
              }
              currentItem.news.stock_tickers = text;
              break;
            case types_1.TagNames["news:language"]:
              if (!currentItem.news) {
                currentItem.news = newsTemplate();
              }
              currentItem.news.publication.language = text;
              break;
            case types_1.TagNames["video:title"]:
              currentVideo.title += text;
              break;
            case types_1.TagNames["video:description"]:
              currentVideo.description += text;
              break;
            case types_1.TagNames["news:name"]:
              if (!currentItem.news) {
                currentItem.news = newsTemplate();
              }
              currentItem.news.publication.name += text;
              break;
            case types_1.TagNames["news:title"]:
              if (!currentItem.news) {
                currentItem.news = newsTemplate();
              }
              currentItem.news.title += text;
              break;
            case types_1.TagNames["image:caption"]:
              if (!currentImage.caption) {
                currentImage.caption = text;
              } else {
                currentImage.caption += text;
              }
              break;
            case types_1.TagNames["image:title"]:
              if (!currentImage.title) {
                currentImage.title = text;
              } else {
                currentImage.title += text;
              }
              break;
            default:
              this.logger("log", "unhandled text for tag:", currentTag, `'${text}'`);
              this.err(`unhandled text for tag: ${currentTag} '${text}'`);
              break;
          }
        });
        this.saxStream.on("cdata", (text) => {
          switch (currentTag) {
            case types_1.TagNames["video:title"]:
              currentVideo.title += text;
              break;
            case types_1.TagNames["video:description"]:
              currentVideo.description += text;
              break;
            case types_1.TagNames["news:name"]:
              if (!currentItem.news) {
                currentItem.news = newsTemplate();
              }
              currentItem.news.publication.name += text;
              break;
            case types_1.TagNames["news:title"]:
              if (!currentItem.news) {
                currentItem.news = newsTemplate();
              }
              currentItem.news.title += text;
              break;
            case types_1.TagNames["image:caption"]:
              if (!currentImage.caption) {
                currentImage.caption = text;
              } else {
                currentImage.caption += text;
              }
              break;
            case types_1.TagNames["image:title"]:
              if (!currentImage.title) {
                currentImage.title = text;
              } else {
                currentImage.title += text;
              }
              break;
            default:
              this.logger("log", "unhandled cdata for tag:", currentTag);
              this.err(`unhandled cdata for tag: ${currentTag}`);
              break;
          }
        });
        this.saxStream.on("attribute", (attr) => {
          switch (currentTag) {
            case types_1.TagNames["urlset"]:
            case types_1.TagNames["xhtml:link"]:
            case types_1.TagNames["video:id"]:
              break;
            case types_1.TagNames["video:restriction"]:
              if (attr.name === "relationship" && (0, types_1.isAllowDeny)(attr.value)) {
                currentVideo["restriction:relationship"] = attr.value;
              } else {
                this.logger("log", "unhandled attr", currentTag, attr.name);
                this.err(`unhandled attr: ${currentTag} ${attr.name}`);
              }
              break;
            case types_1.TagNames["video:price"]:
              if (attr.name === "type" && (0, types_1.isPriceType)(attr.value)) {
                currentVideo["price:type"] = attr.value;
              } else if (attr.name === "currency") {
                currentVideo["price:currency"] = attr.value;
              } else if (attr.name === "resolution" && (0, types_1.isResolution)(attr.value)) {
                currentVideo["price:resolution"] = attr.value;
              } else {
                this.logger("log", "unhandled attr for video:price", attr.name);
                this.err(`unhandled attr: ${currentTag} ${attr.name}`);
              }
              break;
            case types_1.TagNames["video:player_loc"]:
              if (attr.name === "autoplay") {
                currentVideo["player_loc:autoplay"] = attr.value;
              } else if (attr.name === "allow_embed" && (0, types_1.isValidYesNo)(attr.value)) {
                currentVideo["player_loc:allow_embed"] = attr.value;
              } else {
                this.logger("log", "unhandled attr for video:player_loc", attr.name);
                this.err(`unhandled attr: ${currentTag} ${attr.name}`);
              }
              break;
            case types_1.TagNames["video:platform"]:
              if (attr.name === "relationship" && (0, types_1.isAllowDeny)(attr.value)) {
                currentVideo["platform:relationship"] = attr.value;
              } else {
                this.logger("log", "unhandled attr for video:platform", attr.name, attr.value);
                this.err(`unhandled attr: ${currentTag} ${attr.name} ${attr.value}`);
              }
              break;
            case types_1.TagNames["video:gallery_loc"]:
              if (attr.name === "title") {
                currentVideo["gallery_loc:title"] = attr.value;
              } else {
                this.logger("log", "unhandled attr for video:galler_loc", attr.name);
                this.err(`unhandled attr: ${currentTag} ${attr.name}`);
              }
              break;
            case types_1.TagNames["video:uploader"]:
              if (attr.name === "info") {
                currentVideo["uploader:info"] = attr.value;
              } else {
                this.logger("log", "unhandled attr for video:uploader", attr.name);
                this.err(`unhandled attr: ${currentTag} ${attr.name}`);
              }
              break;
            default:
              this.logger("log", "unhandled attr", currentTag, attr.name);
              this.err(`unhandled attr: ${currentTag} ${attr.name}`);
          }
        });
        this.saxStream.on("closetag", (tag) => {
          switch (tag) {
            case types_1.TagNames.url:
              this.push(currentItem);
              currentItem = tagTemplate();
              break;
            case types_1.TagNames["video:video"]:
              currentItem.video.push(currentVideo);
              currentVideo = videoTemplate();
              break;
            case types_1.TagNames["image:image"]:
              currentItem.img.push(currentImage);
              currentImage = { ...imageTemplate };
              break;
            case types_1.TagNames["xhtml:link"]:
              if (!dontpushCurrentLink) {
                currentItem.links.push(currentLink);
              }
              currentLink = { ...linkTemplate };
              break;
            default:
              break;
          }
        });
      }
      _transform(data, encoding, callback) {
        try {
          this.saxStream.write(data, encoding);
          callback(this.level === types_1.ErrorLevel.THROW ? this.error : null);
        } catch (error) {
          callback(error);
        }
      }
      err(msg) {
        if (!this.error)
          this.error = new Error(msg);
      }
    };
    exports.XMLToSitemapItemStream = XMLToSitemapItemStream;
    async function parseSitemap(xml) {
      const urls = [];
      return new Promise((resolve, reject) => {
        xml.pipe(new XMLToSitemapItemStream()).on("data", (smi) => urls.push(smi)).on("end", () => {
          resolve(urls);
        }).on("error", (error) => {
          reject(error);
        });
      });
    }
    exports.parseSitemap = parseSitemap;
    var defaultObjectStreamOpts = {
      lineSeparated: false
    };
    var ObjectStreamToJSON = class extends stream_1.Transform {
      constructor(opts = defaultObjectStreamOpts) {
        opts.writableObjectMode = true;
        super(opts);
        this.lineSeparated = opts.lineSeparated;
        this.firstWritten = false;
      }
      _transform(chunk, encoding, cb) {
        if (!this.firstWritten) {
          this.firstWritten = true;
          if (!this.lineSeparated) {
            this.push("[");
          }
        } else if (this.lineSeparated) {
          this.push("\n");
        } else {
          this.push(",");
        }
        if (chunk) {
          this.push(JSON.stringify(chunk));
        }
        cb();
      }
      _flush(cb) {
        if (!this.lineSeparated) {
          this.push("]");
        }
        cb();
      }
    };
    exports.ObjectStreamToJSON = ObjectStreamToJSON;
  }
});

// node_modules/sitemap/dist/lib/sitemap-index-parser.js
var require_sitemap_index_parser = __commonJS({
  "node_modules/sitemap/dist/lib/sitemap-index-parser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndexObjectStreamToJSON = exports.parseSitemapIndex = exports.XMLToSitemapIndexStream = void 0;
    var sax_1 = __importDefault(require_sax());
    var stream_1 = require_stream();
    var types_1 = require_types();
    function isValidTagName(tagName) {
      return tagName in types_1.IndexTagNames;
    }
    function tagTemplate() {
      return {
        url: ""
      };
    }
    var defaultLogger = (level, ...message) => console[level](...message);
    var defaultStreamOpts = {
      logger: defaultLogger
    };
    var XMLToSitemapIndexStream = class extends stream_1.Transform {
      constructor(opts = defaultStreamOpts) {
        var _a;
        opts.objectMode = true;
        super(opts);
        this.saxStream = sax_1.default.createStream(true, {
          xmlns: true,
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          strictEntities: true,
          trim: true
        });
        this.level = opts.level || types_1.ErrorLevel.WARN;
        if (this.level !== types_1.ErrorLevel.SILENT && opts.logger !== false) {
          this.logger = (_a = opts.logger) !== null && _a !== void 0 ? _a : defaultLogger;
        } else {
          this.logger = () => void 0;
        }
        let currentItem = tagTemplate();
        let currentTag;
        this.saxStream.on("opentagstart", (tag) => {
          currentTag = tag.name;
        });
        this.saxStream.on("opentag", (tag) => {
          if (!isValidTagName(tag.name)) {
            this.logger("warn", "unhandled tag", tag.name);
          }
        });
        this.saxStream.on("text", (text) => {
          switch (currentTag) {
            case types_1.IndexTagNames.loc:
              currentItem.url = text;
              break;
            case types_1.IndexTagNames.lastmod:
              currentItem.lastmod = text;
              break;
            default:
              this.logger("log", "unhandled text for tag:", currentTag, `'${text}'`);
              break;
          }
        });
        this.saxStream.on("cdata", (_text) => {
          switch (currentTag) {
            default:
              this.logger("log", "unhandled cdata for tag:", currentTag);
              break;
          }
        });
        this.saxStream.on("attribute", (attr) => {
          switch (currentTag) {
            case types_1.IndexTagNames.sitemapindex:
              break;
            default:
              this.logger("log", "unhandled attr", currentTag, attr.name);
          }
        });
        this.saxStream.on("closetag", (tag) => {
          switch (tag) {
            case types_1.IndexTagNames.sitemap:
              this.push(currentItem);
              currentItem = tagTemplate();
              break;
            default:
              break;
          }
        });
      }
      _transform(data, encoding, callback) {
        try {
          this.saxStream.write(data, encoding);
          callback();
        } catch (error) {
          callback(error);
        }
      }
    };
    exports.XMLToSitemapIndexStream = XMLToSitemapIndexStream;
    async function parseSitemapIndex(xml) {
      const urls = [];
      return new Promise((resolve, reject) => {
        xml.pipe(new XMLToSitemapIndexStream()).on("data", (smi) => urls.push(smi)).on("end", () => {
          resolve(urls);
        }).on("error", (error) => {
          reject(error);
        });
      });
    }
    exports.parseSitemapIndex = parseSitemapIndex;
    var defaultObjectStreamOpts = {
      lineSeparated: false
    };
    var IndexObjectStreamToJSON = class extends stream_1.Transform {
      constructor(opts = defaultObjectStreamOpts) {
        opts.writableObjectMode = true;
        super(opts);
        this.lineSeparated = opts.lineSeparated;
        this.firstWritten = false;
      }
      _transform(chunk, encoding, cb) {
        if (!this.firstWritten) {
          this.firstWritten = true;
          if (!this.lineSeparated) {
            this.push("[");
          }
        } else if (this.lineSeparated) {
          this.push("\n");
        } else {
          this.push(",");
        }
        if (chunk) {
          this.push(JSON.stringify(chunk));
        }
        cb();
      }
      _flush(cb) {
        if (!this.lineSeparated) {
          this.push("]");
        }
        cb();
      }
    };
    exports.IndexObjectStreamToJSON = IndexObjectStreamToJSON;
  }
});

// browser-external:zlib
var require_zlib = __commonJS({
  "browser-external:zlib"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "zlib" has been externalized for browser compatibility. Cannot access "zlib.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/sitemap/dist/lib/sitemap-simple.js
var require_sitemap_simple = __commonJS({
  "node_modules/sitemap/dist/lib/sitemap-simple.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.simpleSitemapAndIndex = void 0;
    var index_1 = require_dist();
    var zlib_1 = require_zlib();
    var fs_1 = require_fs();
    var path_1 = require_path();
    var stream_1 = require_stream();
    var util_1 = require_util();
    var url_1 = require_url();
    var pipeline = (0, util_1.promisify)(stream_1.pipeline);
    var simpleSitemapAndIndex2 = async ({
      hostname,
      sitemapHostname = hostname,
      // if different
      /**
       * Pass a line separated list of sitemap items or a stream or an array
       */
      sourceData,
      destinationDir,
      limit = 5e4,
      gzip = true,
      publicBasePath = "./"
    }) => {
      await fs_1.promises.mkdir(destinationDir, { recursive: true });
      const sitemapAndIndexStream = new index_1.SitemapAndIndexStream({
        limit,
        getSitemapStream: (i) => {
          const sitemapStream = new index_1.SitemapStream({
            hostname
          });
          const path = `./sitemap-${i}.xml`;
          const writePath2 = (0, path_1.resolve)(destinationDir, path + (gzip ? ".gz" : ""));
          if (!publicBasePath.endsWith("/")) {
            publicBasePath += "/";
          }
          const publicPath = (0, path_1.normalize)(publicBasePath + path);
          let pipeline2;
          if (gzip) {
            pipeline2 = sitemapStream.pipe((0, zlib_1.createGzip)()).pipe((0, fs_1.createWriteStream)(writePath2));
          } else {
            pipeline2 = sitemapStream.pipe((0, fs_1.createWriteStream)(writePath2));
          }
          return [
            new url_1.URL(`${publicPath}${gzip ? ".gz" : ""}`, sitemapHostname).toString(),
            sitemapStream,
            pipeline2
          ];
        }
      });
      let src;
      if (typeof sourceData === "string") {
        src = (0, index_1.lineSeparatedURLsToSitemapOptions)((0, fs_1.createReadStream)(sourceData));
      } else if (sourceData instanceof stream_1.Readable) {
        src = sourceData;
      } else if (Array.isArray(sourceData)) {
        src = stream_1.Readable.from(sourceData);
      } else {
        throw new Error("unhandled source type. You've passed in data that is not supported");
      }
      const writePath = (0, path_1.resolve)(destinationDir, `./sitemap-index.xml${gzip ? ".gz" : ""}`);
      if (gzip) {
        return pipeline(src, sitemapAndIndexStream, (0, zlib_1.createGzip)(), (0, fs_1.createWriteStream)(writePath));
      } else {
        return pipeline(src, sitemapAndIndexStream, (0, fs_1.createWriteStream)(writePath));
      }
    };
    exports.simpleSitemapAndIndex = simpleSitemapAndIndex2;
    exports.default = exports.simpleSitemapAndIndex;
  }
});

// node_modules/sitemap/dist/index.js
var require_dist = __commonJS({
  "node_modules/sitemap/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.simpleSitemapAndIndex = exports.IndexObjectStreamToJSON = exports.XMLToSitemapIndexStream = exports.parseSitemapIndex = exports.ObjectStreamToJSON = exports.XMLToSitemapItemStream = exports.parseSitemap = exports.xmlLint = exports.ReadlineStream = exports.normalizeURL = exports.validateSMIOptions = exports.mergeStreams = exports.lineSeparatedURLsToSitemapOptions = exports.SitemapStream = exports.streamToPromise = exports.SitemapAndIndexStream = exports.SitemapIndexStream = exports.IndexTagNames = exports.SitemapItemStream = void 0;
    var sitemap_item_stream_1 = require_sitemap_item_stream();
    Object.defineProperty(exports, "SitemapItemStream", { enumerable: true, get: function() {
      return sitemap_item_stream_1.SitemapItemStream;
    } });
    var sitemap_index_stream_1 = require_sitemap_index_stream();
    Object.defineProperty(exports, "IndexTagNames", { enumerable: true, get: function() {
      return sitemap_index_stream_1.IndexTagNames;
    } });
    Object.defineProperty(exports, "SitemapIndexStream", { enumerable: true, get: function() {
      return sitemap_index_stream_1.SitemapIndexStream;
    } });
    Object.defineProperty(exports, "SitemapAndIndexStream", { enumerable: true, get: function() {
      return sitemap_index_stream_1.SitemapAndIndexStream;
    } });
    var sitemap_stream_1 = require_sitemap_stream();
    Object.defineProperty(exports, "streamToPromise", { enumerable: true, get: function() {
      return sitemap_stream_1.streamToPromise;
    } });
    Object.defineProperty(exports, "SitemapStream", { enumerable: true, get: function() {
      return sitemap_stream_1.SitemapStream;
    } });
    __exportStar(require_errors(), exports);
    __exportStar(require_types(), exports);
    var utils_1 = require_utils();
    Object.defineProperty(exports, "lineSeparatedURLsToSitemapOptions", { enumerable: true, get: function() {
      return utils_1.lineSeparatedURLsToSitemapOptions;
    } });
    Object.defineProperty(exports, "mergeStreams", { enumerable: true, get: function() {
      return utils_1.mergeStreams;
    } });
    Object.defineProperty(exports, "validateSMIOptions", { enumerable: true, get: function() {
      return utils_1.validateSMIOptions;
    } });
    Object.defineProperty(exports, "normalizeURL", { enumerable: true, get: function() {
      return utils_1.normalizeURL;
    } });
    Object.defineProperty(exports, "ReadlineStream", { enumerable: true, get: function() {
      return utils_1.ReadlineStream;
    } });
    var xmllint_1 = require_xmllint();
    Object.defineProperty(exports, "xmlLint", { enumerable: true, get: function() {
      return xmllint_1.xmlLint;
    } });
    var sitemap_parser_1 = require_sitemap_parser();
    Object.defineProperty(exports, "parseSitemap", { enumerable: true, get: function() {
      return sitemap_parser_1.parseSitemap;
    } });
    Object.defineProperty(exports, "XMLToSitemapItemStream", { enumerable: true, get: function() {
      return sitemap_parser_1.XMLToSitemapItemStream;
    } });
    Object.defineProperty(exports, "ObjectStreamToJSON", { enumerable: true, get: function() {
      return sitemap_parser_1.ObjectStreamToJSON;
    } });
    var sitemap_index_parser_1 = require_sitemap_index_parser();
    Object.defineProperty(exports, "parseSitemapIndex", { enumerable: true, get: function() {
      return sitemap_index_parser_1.parseSitemapIndex;
    } });
    Object.defineProperty(exports, "XMLToSitemapIndexStream", { enumerable: true, get: function() {
      return sitemap_index_parser_1.XMLToSitemapIndexStream;
    } });
    Object.defineProperty(exports, "IndexObjectStreamToJSON", { enumerable: true, get: function() {
      return sitemap_index_parser_1.IndexObjectStreamToJSON;
    } });
    var sitemap_simple_1 = require_sitemap_simple();
    Object.defineProperty(exports, "simpleSitemapAndIndex", { enumerable: true, get: function() {
      return sitemap_simple_1.simpleSitemapAndIndex;
    } });
  }
});

// node_modules/@astrojs/sitemap/dist/index.js
var import_sitemap2 = __toESM(require_dist());
var import_url = __toESM(require_url());

// node_modules/@astrojs/sitemap/dist/utils/parse-url.js
var parseUrl = (url, defaultLocale, localeCodes, base) => {
  if (!url || !defaultLocale || localeCodes.length === 0 || localeCodes.some((key) => !key) || !base) {
    throw new Error("parseUrl: some parameters are empty");
  }
  if (url.indexOf(base) !== 0) {
    return void 0;
  }
  let s = url.replace(base, "");
  if (!s || s === "/") {
    return { locale: defaultLocale, path: "/" };
  }
  if (!s.startsWith("/")) {
    s = "/" + s;
  }
  const a = s.split("/");
  const locale = a[1];
  if (localeCodes.some((key) => key === locale)) {
    let path = a.slice(2).join("/");
    if (path === "//") {
      path = "/";
    }
    if (path !== "/" && !path.startsWith("/")) {
      path = "/" + path;
    }
    return { locale, path };
  }
  return { locale: defaultLocale, path: s };
};

// node_modules/@astrojs/sitemap/dist/generate-sitemap.js
var STATUS_CODE_PAGE_REGEXP = /\/[0-9]{3}\/?$/;
function generateSitemap(pages, finalSiteUrl, opts) {
  const { changefreq, priority, lastmod: lastmodSrc, i18n } = opts;
  const urls = [...pages].filter((url) => !STATUS_CODE_PAGE_REGEXP.test(url));
  urls.sort((a, b) => a.localeCompare(b, "en", { numeric: true }));
  const lastmod = lastmodSrc == null ? void 0 : lastmodSrc.toISOString();
  const { locales, defaultLocale } = i18n || {};
  const localeCodes = Object.keys(locales || {});
  const getPath = (url) => {
    const result = parseUrl(url, (i18n == null ? void 0 : i18n.defaultLocale) || "", localeCodes, finalSiteUrl);
    return result == null ? void 0 : result.path;
  };
  const getLocale = (url) => {
    const result = parseUrl(url, (i18n == null ? void 0 : i18n.defaultLocale) || "", localeCodes, finalSiteUrl);
    return result == null ? void 0 : result.locale;
  };
  const urlData = urls.map((url) => {
    let links;
    if (defaultLocale && locales) {
      const currentPath = getPath(url);
      if (currentPath) {
        const filtered = urls.filter((subUrl) => getPath(subUrl) === currentPath);
        if (filtered.length > 1) {
          links = filtered.map((subUrl) => ({
            url: subUrl,
            lang: locales[getLocale(subUrl)]
          }));
        }
      }
    }
    return {
      url,
      links,
      lastmod,
      priority,
      changefreq
    };
  });
  return urlData;
}

// node_modules/@astrojs/sitemap/dist/utils/logger.js
var Logger = class {
  constructor(packageName) {
    this.colors = {
      reset: "\x1B[0m",
      fg: {
        red: "\x1B[31m",
        green: "\x1B[32m",
        yellow: "\x1B[33m"
      }
    };
    this.packageName = packageName;
  }
  log(msg, prefix = "") {
    console.log(`%s${this.packageName}:%s ${msg}
`, prefix, prefix ? this.colors.reset : "");
  }
  info(msg) {
    this.log(msg);
  }
  success(msg) {
    this.log(msg, this.colors.fg.green);
  }
  warn(msg) {
    this.log(`Skipped!
${msg}`, this.colors.fg.yellow);
  }
  error(msg) {
    this.log(`Failed!
${msg}`, this.colors.fg.red);
  }
};

// node_modules/@astrojs/sitemap/dist/schema.js
var import_sitemap = __toESM(require_dist(), 1);

// node_modules/@astrojs/sitemap/dist/config-defaults.js
var SITEMAP_CONFIG_DEFAULTS = {
  entryLimit: 45e3
};

// node_modules/@astrojs/sitemap/dist/schema.js
var localeKeySchema = mod.string().min(1);
var SitemapOptionsSchema = mod.object({
  filter: mod.function().args(mod.string()).returns(mod.boolean()).optional(),
  customPages: mod.string().url().array().optional(),
  canonicalURL: mod.string().url().optional(),
  i18n: mod.object({
    defaultLocale: localeKeySchema,
    locales: mod.record(
      localeKeySchema,
      mod.string().min(2).regex(/^[a-zA-Z\-]+$/gm, {
        message: "Only English alphabet symbols and hyphen allowed"
      })
    )
  }).refine((val) => !val || val.locales[val.defaultLocale], {
    message: "`defaultLocale` must exist in `locales` keys"
  }).optional(),
  entryLimit: mod.number().nonnegative().optional().default(SITEMAP_CONFIG_DEFAULTS.entryLimit),
  serialize: mod.function().args(mod.any()).returns(mod.any()).optional(),
  changefreq: mod.nativeEnum(import_sitemap.EnumChangefreq).optional(),
  lastmod: mod.date().optional(),
  priority: mod.number().min(0).max(1).optional()
}).strict().default(SITEMAP_CONFIG_DEFAULTS);

// node_modules/@astrojs/sitemap/dist/validate-options.js
var validateOptions = (site, opts) => {
  const result = SitemapOptionsSchema.parse(opts);
  mod.object({
    site: mod.string().optional(),
    canonicalURL: mod.string().optional()
  }).refine((options) => options.site || options.canonicalURL, {
    message: "Required `site` astro.config option or `canonicalURL` integration option"
  }).parse({
    site,
    canonicalURL: result.canonicalURL
  });
  return result;
};

// node_modules/@astrojs/sitemap/dist/index.js
function formatConfigErrorMessage(err) {
  const errorList = err.issues.map((issue) => ` ${issue.path.join(".")}  ${issue.message + "."}`);
  return errorList.join("\n");
}
var PKG_NAME = "@astrojs/sitemap";
var OUTFILE = "sitemap-index.xml";
var createPlugin = (options) => {
  let config;
  return {
    name: PKG_NAME,
    hooks: {
      "astro:config:done": async ({ config: cfg }) => {
        config = cfg;
      },
      "astro:build:done": async ({ dir, pages }) => {
        const logger = new Logger(PKG_NAME);
        try {
          const opts = validateOptions(config.site, options);
          const { filter, customPages, serialize, entryLimit } = opts;
          let finalSiteUrl;
          if (config.site) {
            finalSiteUrl = new URL(config.base, config.site);
          } else {
            console.warn(
              "The Sitemap integration requires the `site` astro.config option. Skipping."
            );
            return;
          }
          let pageUrls = pages.map((p) => {
            const path = finalSiteUrl.pathname + p.pathname;
            return new URL(path, finalSiteUrl).href;
          });
          try {
            if (filter) {
              pageUrls = pageUrls.filter(filter);
            }
          } catch (err) {
            logger.error(`Error filtering pages
${err.toString()}`);
            return;
          }
          if (customPages) {
            pageUrls = [...pageUrls, ...customPages];
          }
          if (pageUrls.length === 0) {
            if (config.output !== "static") {
              logger.warn(
                `No pages found! We can only detect sitemap routes for "static" builds. Since you are using an SSR adapter, we recommend manually listing your sitemap routes using the "customPages" integration option.

Example: \`sitemap({ customPages: ['https://example.com/route'] })\``
              );
            } else {
              logger.warn(`No pages found!
\`${OUTFILE}\` not created.`);
            }
            return;
          }
          let urlData = generateSitemap(pageUrls, finalSiteUrl.href, opts);
          if (serialize) {
            try {
              const serializedUrls = [];
              for (const item of urlData) {
                const serialized = await Promise.resolve(serialize(item));
                if (serialized) {
                  serializedUrls.push(serialized);
                }
              }
              if (serializedUrls.length === 0) {
                logger.warn("No pages found!");
                return;
              }
              urlData = serializedUrls;
            } catch (err) {
              logger.error(`Error serializing pages
${err.toString()}`);
              return;
            }
          }
          await (0, import_sitemap2.simpleSitemapAndIndex)({
            hostname: finalSiteUrl.href,
            destinationDir: (0, import_url.fileURLToPath)(dir),
            sourceData: urlData,
            limit: entryLimit,
            gzip: false
          });
          logger.success(`\`${OUTFILE}\` is created.`);
        } catch (err) {
          if (err instanceof ZodError) {
            logger.warn(formatConfigErrorMessage(err));
          } else {
            throw err;
          }
        }
      }
    }
  };
};
var src_default = createPlugin;
export {
  src_default as default
};
/*! Bundled license information:

sitemap/dist/lib/errors.js:
  (*!
   * Sitemap
   * Copyright(c) 2011 Eugene Kalinin
   * MIT Licensed
   *)

sitemap/dist/lib/utils.js:
  (*!
   * Sitemap
   * Copyright(c) 2011 Eugene Kalinin
   * MIT Licensed
   *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

sax/lib/sax.js:
  (*! http://mths.be/fromcodepoint v0.1.0 by @mathias *)

sitemap/dist/index.js:
  (*!
   * Sitemap
   * Copyright(c) 2011 Eugene Kalinin
   * MIT Licensed
   *)
*/
//# sourceMappingURL=@astrojs_sitemap.js.map
