import {
  parse
} from "./chunk-KCL2YP4O.js";
import {
  require_node_path
} from "./chunk-6YZLRXNM.js";
import {
  __toESM
} from "./chunk-OZI5HTJH.js";

// node_modules/astro-auto-import/dist/index.js
var import_node_path = __toESM(require_node_path());
var resolveModulePath = (path) => {
  if (path.startsWith("."))
    return (0, import_node_path.resolve)(path);
  return path;
};
function getDefaultImportName(path) {
  return (0, import_node_path.parse)(path).name.replaceAll(/[^\w\d]/g, "");
}
function formatImport(imported, module) {
  return `import ${imported} from '${module}';`;
}
function formatExposure(name) {
  return `globalThis.${name} = ${name};`;
}
function formatNamedImports(namedImport) {
  const imports = [];
  const exposedNames = [];
  for (const imp of namedImport) {
    if (typeof imp === "string") {
      imports.push(imp);
      exposedNames.push(imp);
    } else {
      const [from, as] = imp;
      imports.push(`${from} as ${as}`);
      exposedNames.push(as);
    }
  }
  return [`{ ${imports.join(", ")} }`, exposedNames.map(formatExposure)];
}
function processImportsConfig(config) {
  const imports = [];
  const exposures = [];
  for (const option of config) {
    if (typeof option === "string") {
      imports.push(formatImport(getDefaultImportName(option), resolveModulePath(option)));
      exposures.push(formatExposure(getDefaultImportName(option)));
    } else {
      for (const path in option) {
        const namedImports = option[path];
        const [importString, exposureArray] = formatNamedImports(namedImports);
        imports.push(formatImport(importString, resolveModulePath(path)));
        exposures.push(...exposureArray);
      }
    }
  }
  return { imports, exposures };
}
function generateScript(config) {
  const { imports, exposures } = processImportsConfig(config);
  return [...imports, ...exposures].join("\n");
}
function generateImportsNode(config) {
  const { imports } = processImportsConfig(config);
  const js = imports.join("\n");
  return {
    type: "mdxjsEsm",
    value: "",
    data: {
      estree: {
        body: [],
        ...parse(js, { ecmaVersion: "latest", sourceType: "module" }),
        type: "Program",
        sourceType: "module"
      }
    }
  };
}
function AutoImport(integrationConfig) {
  return {
    name: "auto-import",
    hooks: {
      "astro:config:setup": ({ injectScript, config, updateConfig }) => {
        injectScript("page-ssr", generateScript(integrationConfig.imports));
        const hasMarkdownPlugins = !!(config.markdown.remarkPlugins.length || config.markdown.rehypePlugins.length);
        const mdxIndex = config.integrations.findIndex((i) => i.name === "@astrojs/mdx");
        const thisIndex = config.integrations.findIndex((i) => i.name === "auto-import");
        if (mdxIndex >= 0 && mdxIndex < thisIndex) {
          console.warn("[auto-import] ⚠️ @astrojs/mdx initialized BEFORE astro-auto-import.\n              Auto imports in .mdx files won’t work!\n              Move the MDX integration after auto-import in your integrations array in astro.config.");
        }
        if (mdxIndex === -1)
          return;
        const importsNode = generateImportsNode(integrationConfig.imports);
        updateConfig({
          markdown: {
            extendDefaultPlugins: config.markdown.extendDefaultPlugins ?? !hasMarkdownPlugins,
            remarkPlugins: [
              function rehypeInjectMdxImports() {
                return function injectMdxImports(tree, vfile) {
                  var _a;
                  if (!((_a = vfile.basename) == null ? void 0 : _a.endsWith(".md"))) {
                    tree.children.unshift(importsNode);
                  }
                };
              }
            ]
          }
        });
      }
    }
  };
}
export {
  AutoImport as default
};
//# sourceMappingURL=astro-auto-import.js.map
