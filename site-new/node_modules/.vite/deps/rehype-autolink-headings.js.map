{
  "version": 3,
  "sources": ["../../../../node_modules/rehype-autolink-headings/lib/index.js", "../../../../node_modules/hast-util-has-property/lib/index.js", "../../../../node_modules/hast-util-heading-rank/lib/index.js", "../../../../node_modules/hast-util-is-element/index.js"],
  "sourcesContent": ["/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Parent} Parent\n * @typedef {import('hast').Element} Element\n * @typedef {Element['children'][number]} ElementChild\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast-util-is-element').Test} Test\n *\n * @typedef {'prepend'|'append'|'wrap'|'before'|'after'} Behavior\n *\n * @callback Build\n * @param {Element} node\n * @returns {ElementChild|ElementChild[]}\n *\n * @typedef Options\n *   Configuration.\n * @property {Behavior} [behavior='prepend']\n *   How to create links.\n * @property {Behavior} [behaviour]\n *   Please use `behavior` instead\n * @property {Properties} [properties]\n *   Extra properties to set on the link when injecting.\n *   Defaults to `{ariaHidden: true, tabIndex: -1}` when `'prepend'` or\n *   `'append'`.\n * @property {ElementChild|ElementChild[]|Build} [content={type: 'element', tagName: 'span', properties: {className: ['icon', 'icon-link']}, children: []}]\n *   hast nodes to insert in the link.\n * @property {ElementChild|ElementChild[]|Build} [group]\n *   hast node to wrap the heading and link with, if `behavior` is `'before'` or\n *   `'after'`.\n *   There is no default.\n * @property {Test} [test]\n *   Test to define which heading elements are linked.\n *   Any test that can be given to `hast-util-is-element` is supported.\n *   The default (no test) is to link all headings.\n *   Can be used to link only h1-h3, or for example all except h1.\n */\n\nimport extend from 'extend'\nimport {hasProperty} from 'hast-util-has-property'\nimport {headingRank} from 'hast-util-heading-rank'\nimport {convertElement} from 'hast-util-is-element'\nimport {visit, SKIP} from 'unist-util-visit'\n\n/** @type {Element} */\nconst contentDefaults = {\n  type: 'element',\n  tagName: 'span',\n  properties: {className: ['icon', 'icon-link']},\n  children: []\n}\n\n/**\n * Plugin to automatically add links to headings (h1-h6).\n *\n * @type {import('unified').Plugin<[Options?]|void[], Root>}\n */\nexport default function rehypeAutolinkHeadings(options = {}) {\n  let props = options.properties\n  const behavior = options.behaviour || options.behavior || 'prepend'\n  const content = options.content || contentDefaults\n  const group = options.group\n  const is = convertElement(options.test)\n\n  /** @type {import('unist-util-visit/complex-types').Visitor<Element>} */\n  let method\n\n  if (behavior === 'wrap') {\n    method = wrap\n  } else if (behavior === 'before' || behavior === 'after') {\n    method = around\n  } else {\n    if (!props) {\n      props = {ariaHidden: 'true', tabIndex: -1}\n    }\n\n    method = inject\n  }\n\n  return (tree) => {\n    visit(tree, 'element', (node, index, parent) => {\n      if (\n        headingRank(node) &&\n        hasProperty(node, 'id') &&\n        is(node, index, parent)\n      ) {\n        return method(node, index, parent)\n      }\n    })\n  }\n\n  /** @type {import('unist-util-visit/complex-types').Visitor<Element>} */\n  function inject(node) {\n    node.children[behavior === 'prepend' ? 'unshift' : 'push'](\n      create(node, extend(true, {}, props), toChildren(content, node))\n    )\n\n    return [SKIP]\n  }\n\n  /** @type {import('unist-util-visit/complex-types').Visitor<Element>} */\n  function around(node, index, parent) {\n    // Uncommon.\n    /* c8 ignore next */\n    if (typeof index !== 'number' || !parent) return\n\n    const link = create(\n      node,\n      extend(true, {}, props),\n      toChildren(content, node)\n    )\n    let nodes = behavior === 'before' ? [link, node] : [node, link]\n\n    if (group) {\n      const grouping = toNode(group, node)\n\n      if (grouping && !Array.isArray(grouping) && grouping.type === 'element') {\n        grouping.children = nodes\n        nodes = [grouping]\n      }\n    }\n\n    parent.children.splice(index, 1, ...nodes)\n\n    return [SKIP, index + nodes.length]\n  }\n\n  /** @type {import('unist-util-visit/complex-types').Visitor<Element>} */\n  function wrap(node) {\n    node.children = [create(node, extend(true, {}, props), node.children)]\n    return [SKIP]\n  }\n\n  /**\n   * @param {ElementChild|ElementChild[]|Build} value\n   * @param {Element} node\n   * @returns {ElementChild[]}\n   */\n  function toChildren(value, node) {\n    const result = toNode(value, node)\n    return Array.isArray(result) ? result : [result]\n  }\n\n  /**\n   * @param {ElementChild|ElementChild[]|Build} value\n   * @param {Element} node\n   * @returns {ElementChild|ElementChild[]}\n   */\n  function toNode(value, node) {\n    if (typeof value === 'function') return value(node)\n    return extend(true, Array.isArray(value) ? [] : {}, value)\n  }\n\n  /**\n   * @param {Element} node\n   * @param {Properties} props\n   * @param {ElementChild[]} children\n   * @returns {Element}\n   */\n  function create(node, props, children) {\n    return {\n      type: 'element',\n      tagName: 'a',\n      properties: Object.assign({}, props, {\n        // Fix hast types and make them required.\n        /* c8 ignore next */\n        href: '#' + (node.properties || {}).id\n      }),\n      children\n    }\n  }\n}\n", "/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Content} Content\n */\n\n/**\n * @typedef {Root | Content} Node\n */\n\nconst own = {}.hasOwnProperty\n\n/**\n * Check if `node`is an element and has a `field` property.\n *\n * @param {unknown} node\n *   Thing to check (typically `Element`).\n * @param {unknown} field\n *   Field name to check (typically `string`).\n * @returns {boolean}\n *   Whether `node` is an element that has a `field` property.\n */\nexport function hasProperty(node, field) {\n  const value =\n    typeof field === 'string' &&\n    isNode(node) &&\n    node.type === 'element' &&\n    node.properties &&\n    own.call(node.properties, field) &&\n    node.properties[field]\n\n  return value !== null && value !== undefined && value !== false\n}\n\n/**\n * @param {unknown} value\n * @returns {value is Node}\n */\nfunction isNode(value) {\n  return Boolean(value && typeof value === 'object' && 'type' in value)\n}\n", "/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Content} Content\n */\n\n/**\n * @typedef {Root | Content} Node\n */\n\n// To do next major: return `undefined`.\n/**\n * Get the rank (`1` to `6`) of headings (`h1` to `h6`).\n *\n * @param {Node} node\n *   Node to check.\n * @returns {number | null}\n *   Rank of the heading or `null` if not a heading.\n */\nexport function headingRank(node) {\n  const name =\n    (node && node.type === 'element' && node.tagName.toLowerCase()) || ''\n  const code =\n    name.length === 2 && name.charCodeAt(0) === 104 /* `h` */\n      ? name.charCodeAt(1)\n      : 0\n  return code > 48 /* `0` */ && code < 55 /* `7` */ ? code - 48 /* `0` */ : null\n}\n", "/**\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('hast').Element} Element\n */\n\n/**\n * @typedef {null | undefined | string | TestFunctionAnything | Array<string | TestFunctionAnything>} Test\n *   Check for an arbitrary element, unaware of TypeScript inferral.\n *\n * @callback TestFunctionAnything\n *   Check if an element passes a test, unaware of TypeScript inferral.\n * @param {Element} element\n *   An element.\n * @param {number | null | undefined} [index]\n *   The element’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The element’s parent.\n * @returns {boolean | void}\n *   Whether this element passes the test.\n */\n\n/**\n * @template {Element} T\n *   Element type.\n * @typedef {T['tagName'] | TestFunctionPredicate<T> | Array<T['tagName'] | TestFunctionPredicate<T>>} PredicateTest\n *   Check for an element that can be inferred by TypeScript.\n */\n\n/**\n * Check if an element passes a certain node test.\n *\n * @template {Element} T\n *   Element type.\n * @callback TestFunctionPredicate\n *   Complex test function for an element that can be inferred by TypeScript.\n * @param {Element} element\n *   An element.\n * @param {number | null | undefined} [index]\n *   The element’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The element’s parent.\n * @returns {element is T}\n *   Whether this element passes the test.\n */\n\n/**\n * @callback AssertAnything\n *   Check that an arbitrary value is an element, unaware of TypeScript inferral.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is an element and passes a test.\n */\n\n/**\n * Check if a node is an element and passes a certain node test\n *\n * @template {Element} T\n *   Element type.\n * @callback AssertPredicate\n *   Check that an arbitrary value is a specific element, aware of TypeScript.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is T}\n *   Whether this is an element and passes a test.\n */\n\n/**\n * Check if `node` is an `Element` and whether it passes the given test.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @param test\n *   A check for a specific element.\n * @param index\n *   The node’s position in its parent.\n * @param parent\n *   The node’s parent.\n * @returns\n *   Whether `node` is an element and passes a test.\n */\nexport const isElement =\n  /**\n   * @type {(\n   *   (() => false) &\n   *   (<T extends Element = Element>(node: unknown, test?: PredicateTest<T>, index?: number, parent?: Parent, context?: unknown) => node is T) &\n   *   ((node: unknown, test: Test, index?: number, parent?: Parent, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test | undefined} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function (node, test, index, parent, context) {\n      const check = convertElement(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index for child node')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!parent.type || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      // @ts-expect-error Looks like a node.\n      if (!node || !node.type || typeof node.type !== 'string') {\n        return false\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      return check.call(context, node, index, parent)\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param test\n *   *  When nullish, checks if `node` is an `Element`.\n *   *  When `string`, works like passing `(element) => element.tagName === test`.\n *   *  When `function` checks if function passed the element is true.\n *   *  When `array`, checks any one of the subtests pass.\n * @returns\n *   An assertion.\n */\nexport const convertElement =\n  /**\n   * @type {(\n   *   (<T extends Element>(test: T['tagName'] | TestFunctionPredicate<T>) => AssertPredicate<T>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  (\n    /**\n     * @param {Test | null | undefined} [test]\n     * @returns {AssertAnything}\n     */\n    function (test) {\n      if (test === undefined || test === null) {\n        return element\n      }\n\n      if (typeof test === 'string') {\n        return tagNameFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return anyFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or array as test')\n    }\n  )\n\n/**\n * Handle multiple tests.\n *\n * @param {Array<string | TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<AssertAnything>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convertElement(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn a string into a test for an element with a certain tag name.\n *\n * @param {string} check\n * @returns {AssertAnything}\n */\nfunction tagNameFactory(check) {\n  return tagName\n\n  /**\n   * @param {unknown} node\n   * @returns {boolean}\n   */\n  function tagName(node) {\n    return element(node) && node.tagName === check\n  }\n}\n\n/**\n * Turn a custom test into a test for an element that passes that test.\n *\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\nfunction castFactory(check) {\n  return assertion\n\n  /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function assertion(node, ...parameters) {\n    // @ts-expect-error: fine.\n    return element(node) && Boolean(check.call(this, node, ...parameters))\n  }\n}\n\n/**\n * Make sure something is an element.\n *\n * @param {unknown} node\n * @returns {node is Element}\n */\nfunction element(node) {\n  return Boolean(\n    node &&\n      typeof node === 'object' &&\n      // @ts-expect-error Looks like a node.\n      node.type === 'element' &&\n      // @ts-expect-error Looks like an element.\n      typeof node.tagName === 'string'\n  )\n}\n"],
  "mappings": "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",
  "names": ["index", "extend", "props"]
}
